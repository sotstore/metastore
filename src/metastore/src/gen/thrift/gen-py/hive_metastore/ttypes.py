#
# Autogenerated by Thrift Compiler (0.9.0)
#
# DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
#
#  options string: py
#

from thrift.Thrift import TType, TMessageType, TException, TApplicationException
import fb303.ttypes


from thrift.transport import TTransport
from thrift.protocol import TBinaryProtocol, TProtocol
try:
  from thrift.protocol import fastbinary
except:
  fastbinary = None


class HiveObjectType:
  GLOBAL = 1
  DATABASE = 2
  TABLE = 3
  PARTITION = 4
  COLUMN = 5

  _VALUES_TO_NAMES = {
    1: "GLOBAL",
    2: "DATABASE",
    3: "TABLE",
    4: "PARTITION",
    5: "COLUMN",
  }

  _NAMES_TO_VALUES = {
    "GLOBAL": 1,
    "DATABASE": 2,
    "TABLE": 3,
    "PARTITION": 4,
    "COLUMN": 5,
  }

class PrincipalType:
  USER = 1
  ROLE = 2
  GROUP = 3

  _VALUES_TO_NAMES = {
    1: "USER",
    2: "ROLE",
    3: "GROUP",
  }

  _NAMES_TO_VALUES = {
    "USER": 1,
    "ROLE": 2,
    "GROUP": 3,
  }

class PartitionEventType:
  LOAD_DONE = 1

  _VALUES_TO_NAMES = {
    1: "LOAD_DONE",
  }

  _NAMES_TO_VALUES = {
    "LOAD_DONE": 1,
  }

class FOFailReason:
  INVALID_NODE = 1
  INVALID_TABLE = 2
  INVALID_FILE = 3
  NOSPACE = 10
  NOTEXIST = 11
  SAFEMODE = 12
  INVALID_STATE = 13

  _VALUES_TO_NAMES = {
    1: "INVALID_NODE",
    2: "INVALID_TABLE",
    3: "INVALID_FILE",
    10: "NOSPACE",
    11: "NOTEXIST",
    12: "SAFEMODE",
    13: "INVALID_STATE",
  }

  _NAMES_TO_VALUES = {
    "INVALID_NODE": 1,
    "INVALID_TABLE": 2,
    "INVALID_FILE": 3,
    "NOSPACE": 10,
    "NOTEXIST": 11,
    "SAFEMODE": 12,
    "INVALID_STATE": 13,
  }

class FindNodePolicy:
  ALL_NGS = 1
  SINGLE_NG = 2

  _VALUES_TO_NAMES = {
    1: "ALL_NGS",
    2: "SINGLE_NG",
  }

  _NAMES_TO_VALUES = {
    "ALL_NGS": 1,
    "SINGLE_NG": 2,
  }

class MSOperation:
  EXPLAIN = 1
  CREATEDATABASE = 2
  DROPDATABASE = 3
  DROPTABLE = 4
  DESCTABLE = 5
  ALTERTABLE_RENAME = 6
  ALTERTABLE_RENAMECOL = 7
  ALTERTABLE_ADDPARTS = 8
  ALTERTABLE_DROPPARTS = 9
  ALTERTABLE_ADDCOLS = 10
  ALTERTABLE_REPLACECOLS = 11
  ALTERTABLE_RENAMEPART = 12
  ALTERTABLE_PROPERTIES = 13
  SHOWDATABASES = 14
  SHOWTABLES = 15
  SHOWCOLUMNS = 16
  SHOW_TABLESTATUS = 17
  SHOW_TBLPROPERTIES = 18
  SHOW_CREATETABLE = 19
  SHOWINDEXES = 20
  SHOWPARTITIONS = 21
  CREATEVIEW = 22
  DROPVIEW = 23
  CREATEINDEX = 24
  DROPINDEX = 25
  ALTERINDEX_REBUILD = 26
  ALTERVIEW_PROPERTIES = 27
  CREATEUSER = 28
  DROPUSER = 29
  CHANGE_PWD = 30
  AUTHENTICATION = 31
  SHOW_USERNAMES = 32
  CREATEROLE = 33
  DROPROLE = 34
  GRANT_PRIVILEGE = 35
  REVOKE_PRIVILEGE = 36
  SHOW_GRANT = 37
  GRANT_ROLE = 38
  REVOKE_ROLE = 39
  SHOW_ROLE_GRANT = 40
  CREATETABLE = 41
  QUERY = 42
  ALTERINDEX_PROPS = 43
  ALTERDATABASE = 44
  DESCDATABASE = 45

  _VALUES_TO_NAMES = {
    1: "EXPLAIN",
    2: "CREATEDATABASE",
    3: "DROPDATABASE",
    4: "DROPTABLE",
    5: "DESCTABLE",
    6: "ALTERTABLE_RENAME",
    7: "ALTERTABLE_RENAMECOL",
    8: "ALTERTABLE_ADDPARTS",
    9: "ALTERTABLE_DROPPARTS",
    10: "ALTERTABLE_ADDCOLS",
    11: "ALTERTABLE_REPLACECOLS",
    12: "ALTERTABLE_RENAMEPART",
    13: "ALTERTABLE_PROPERTIES",
    14: "SHOWDATABASES",
    15: "SHOWTABLES",
    16: "SHOWCOLUMNS",
    17: "SHOW_TABLESTATUS",
    18: "SHOW_TBLPROPERTIES",
    19: "SHOW_CREATETABLE",
    20: "SHOWINDEXES",
    21: "SHOWPARTITIONS",
    22: "CREATEVIEW",
    23: "DROPVIEW",
    24: "CREATEINDEX",
    25: "DROPINDEX",
    26: "ALTERINDEX_REBUILD",
    27: "ALTERVIEW_PROPERTIES",
    28: "CREATEUSER",
    29: "DROPUSER",
    30: "CHANGE_PWD",
    31: "AUTHENTICATION",
    32: "SHOW_USERNAMES",
    33: "CREATEROLE",
    34: "DROPROLE",
    35: "GRANT_PRIVILEGE",
    36: "REVOKE_PRIVILEGE",
    37: "SHOW_GRANT",
    38: "GRANT_ROLE",
    39: "REVOKE_ROLE",
    40: "SHOW_ROLE_GRANT",
    41: "CREATETABLE",
    42: "QUERY",
    43: "ALTERINDEX_PROPS",
    44: "ALTERDATABASE",
    45: "DESCDATABASE",
  }

  _NAMES_TO_VALUES = {
    "EXPLAIN": 1,
    "CREATEDATABASE": 2,
    "DROPDATABASE": 3,
    "DROPTABLE": 4,
    "DESCTABLE": 5,
    "ALTERTABLE_RENAME": 6,
    "ALTERTABLE_RENAMECOL": 7,
    "ALTERTABLE_ADDPARTS": 8,
    "ALTERTABLE_DROPPARTS": 9,
    "ALTERTABLE_ADDCOLS": 10,
    "ALTERTABLE_REPLACECOLS": 11,
    "ALTERTABLE_RENAMEPART": 12,
    "ALTERTABLE_PROPERTIES": 13,
    "SHOWDATABASES": 14,
    "SHOWTABLES": 15,
    "SHOWCOLUMNS": 16,
    "SHOW_TABLESTATUS": 17,
    "SHOW_TBLPROPERTIES": 18,
    "SHOW_CREATETABLE": 19,
    "SHOWINDEXES": 20,
    "SHOWPARTITIONS": 21,
    "CREATEVIEW": 22,
    "DROPVIEW": 23,
    "CREATEINDEX": 24,
    "DROPINDEX": 25,
    "ALTERINDEX_REBUILD": 26,
    "ALTERVIEW_PROPERTIES": 27,
    "CREATEUSER": 28,
    "DROPUSER": 29,
    "CHANGE_PWD": 30,
    "AUTHENTICATION": 31,
    "SHOW_USERNAMES": 32,
    "CREATEROLE": 33,
    "DROPROLE": 34,
    "GRANT_PRIVILEGE": 35,
    "REVOKE_PRIVILEGE": 36,
    "SHOW_GRANT": 37,
    "GRANT_ROLE": 38,
    "REVOKE_ROLE": 39,
    "SHOW_ROLE_GRANT": 40,
    "CREATETABLE": 41,
    "QUERY": 42,
    "ALTERINDEX_PROPS": 43,
    "ALTERDATABASE": 44,
    "DESCDATABASE": 45,
  }


class Version:
  """
  Attributes:
   - version
   - comments
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'version', None, None, ), # 1
    (2, TType.STRING, 'comments', None, None, ), # 2
  )

  def __init__(self, version=None, comments=None,):
    self.version = version
    self.comments = comments

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.version = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.comments = iprot.readString();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('Version')
    if self.version is not None:
      oprot.writeFieldBegin('version', TType.STRING, 1)
      oprot.writeString(self.version)
      oprot.writeFieldEnd()
    if self.comments is not None:
      oprot.writeFieldBegin('comments', TType.STRING, 2)
      oprot.writeString(self.comments)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class FieldSchema:
  """
  Attributes:
   - name
   - type
   - comment
   - version
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'name', None, None, ), # 1
    (2, TType.STRING, 'type', None, None, ), # 2
    (3, TType.STRING, 'comment', None, None, ), # 3
    (4, TType.I64, 'version', None, None, ), # 4
  )

  def __init__(self, name=None, type=None, comment=None, version=None,):
    self.name = name
    self.type = type
    self.comment = comment
    self.version = version

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.name = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.type = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRING:
          self.comment = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.I64:
          self.version = iprot.readI64();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('FieldSchema')
    if self.name is not None:
      oprot.writeFieldBegin('name', TType.STRING, 1)
      oprot.writeString(self.name)
      oprot.writeFieldEnd()
    if self.type is not None:
      oprot.writeFieldBegin('type', TType.STRING, 2)
      oprot.writeString(self.type)
      oprot.writeFieldEnd()
    if self.comment is not None:
      oprot.writeFieldBegin('comment', TType.STRING, 3)
      oprot.writeString(self.comment)
      oprot.writeFieldEnd()
    if self.version is not None:
      oprot.writeFieldBegin('version', TType.I64, 4)
      oprot.writeI64(self.version)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class Type:
  """
  Attributes:
   - name
   - type1
   - type2
   - fields
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'name', None, None, ), # 1
    (2, TType.STRING, 'type1', None, None, ), # 2
    (3, TType.STRING, 'type2', None, None, ), # 3
    (4, TType.LIST, 'fields', (TType.STRUCT,(FieldSchema, FieldSchema.thrift_spec)), None, ), # 4
  )

  def __init__(self, name=None, type1=None, type2=None, fields=None,):
    self.name = name
    self.type1 = type1
    self.type2 = type2
    self.fields = fields

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.name = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.type1 = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRING:
          self.type2 = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.LIST:
          self.fields = []
          (_etype3, _size0) = iprot.readListBegin()
          for _i4 in xrange(_size0):
            _elem5 = FieldSchema()
            _elem5.read(iprot)
            self.fields.append(_elem5)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('Type')
    if self.name is not None:
      oprot.writeFieldBegin('name', TType.STRING, 1)
      oprot.writeString(self.name)
      oprot.writeFieldEnd()
    if self.type1 is not None:
      oprot.writeFieldBegin('type1', TType.STRING, 2)
      oprot.writeString(self.type1)
      oprot.writeFieldEnd()
    if self.type2 is not None:
      oprot.writeFieldBegin('type2', TType.STRING, 3)
      oprot.writeString(self.type2)
      oprot.writeFieldEnd()
    if self.fields is not None:
      oprot.writeFieldBegin('fields', TType.LIST, 4)
      oprot.writeListBegin(TType.STRUCT, len(self.fields))
      for iter6 in self.fields:
        iter6.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class HiveObjectRef:
  """
  Attributes:
   - objectType
   - dbName
   - objectName
   - partValues
   - columnName
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, 'objectType', None, None, ), # 1
    (2, TType.STRING, 'dbName', None, None, ), # 2
    (3, TType.STRING, 'objectName', None, None, ), # 3
    (4, TType.LIST, 'partValues', (TType.STRING,None), None, ), # 4
    (5, TType.STRING, 'columnName', None, None, ), # 5
  )

  def __init__(self, objectType=None, dbName=None, objectName=None, partValues=None, columnName=None,):
    self.objectType = objectType
    self.dbName = dbName
    self.objectName = objectName
    self.partValues = partValues
    self.columnName = columnName

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.objectType = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.dbName = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRING:
          self.objectName = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.LIST:
          self.partValues = []
          (_etype10, _size7) = iprot.readListBegin()
          for _i11 in xrange(_size7):
            _elem12 = iprot.readString();
            self.partValues.append(_elem12)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.STRING:
          self.columnName = iprot.readString();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('HiveObjectRef')
    if self.objectType is not None:
      oprot.writeFieldBegin('objectType', TType.I32, 1)
      oprot.writeI32(self.objectType)
      oprot.writeFieldEnd()
    if self.dbName is not None:
      oprot.writeFieldBegin('dbName', TType.STRING, 2)
      oprot.writeString(self.dbName)
      oprot.writeFieldEnd()
    if self.objectName is not None:
      oprot.writeFieldBegin('objectName', TType.STRING, 3)
      oprot.writeString(self.objectName)
      oprot.writeFieldEnd()
    if self.partValues is not None:
      oprot.writeFieldBegin('partValues', TType.LIST, 4)
      oprot.writeListBegin(TType.STRING, len(self.partValues))
      for iter13 in self.partValues:
        oprot.writeString(iter13)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.columnName is not None:
      oprot.writeFieldBegin('columnName', TType.STRING, 5)
      oprot.writeString(self.columnName)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class PrivilegeGrantInfo:
  """
  Attributes:
   - privilege
   - createTime
   - grantor
   - grantorType
   - grantOption
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'privilege', None, None, ), # 1
    (2, TType.I32, 'createTime', None, None, ), # 2
    (3, TType.STRING, 'grantor', None, None, ), # 3
    (4, TType.I32, 'grantorType', None, None, ), # 4
    (5, TType.BOOL, 'grantOption', None, None, ), # 5
  )

  def __init__(self, privilege=None, createTime=None, grantor=None, grantorType=None, grantOption=None,):
    self.privilege = privilege
    self.createTime = createTime
    self.grantor = grantor
    self.grantorType = grantorType
    self.grantOption = grantOption

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.privilege = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I32:
          self.createTime = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRING:
          self.grantor = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.I32:
          self.grantorType = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.BOOL:
          self.grantOption = iprot.readBool();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('PrivilegeGrantInfo')
    if self.privilege is not None:
      oprot.writeFieldBegin('privilege', TType.STRING, 1)
      oprot.writeString(self.privilege)
      oprot.writeFieldEnd()
    if self.createTime is not None:
      oprot.writeFieldBegin('createTime', TType.I32, 2)
      oprot.writeI32(self.createTime)
      oprot.writeFieldEnd()
    if self.grantor is not None:
      oprot.writeFieldBegin('grantor', TType.STRING, 3)
      oprot.writeString(self.grantor)
      oprot.writeFieldEnd()
    if self.grantorType is not None:
      oprot.writeFieldBegin('grantorType', TType.I32, 4)
      oprot.writeI32(self.grantorType)
      oprot.writeFieldEnd()
    if self.grantOption is not None:
      oprot.writeFieldBegin('grantOption', TType.BOOL, 5)
      oprot.writeBool(self.grantOption)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class HiveObjectPrivilege:
  """
  Attributes:
   - hiveObject
   - principalName
   - principalType
   - grantInfo
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'hiveObject', (HiveObjectRef, HiveObjectRef.thrift_spec), None, ), # 1
    (2, TType.STRING, 'principalName', None, None, ), # 2
    (3, TType.I32, 'principalType', None, None, ), # 3
    (4, TType.STRUCT, 'grantInfo', (PrivilegeGrantInfo, PrivilegeGrantInfo.thrift_spec), None, ), # 4
  )

  def __init__(self, hiveObject=None, principalName=None, principalType=None, grantInfo=None,):
    self.hiveObject = hiveObject
    self.principalName = principalName
    self.principalType = principalType
    self.grantInfo = grantInfo

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.hiveObject = HiveObjectRef()
          self.hiveObject.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.principalName = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.I32:
          self.principalType = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRUCT:
          self.grantInfo = PrivilegeGrantInfo()
          self.grantInfo.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('HiveObjectPrivilege')
    if self.hiveObject is not None:
      oprot.writeFieldBegin('hiveObject', TType.STRUCT, 1)
      self.hiveObject.write(oprot)
      oprot.writeFieldEnd()
    if self.principalName is not None:
      oprot.writeFieldBegin('principalName', TType.STRING, 2)
      oprot.writeString(self.principalName)
      oprot.writeFieldEnd()
    if self.principalType is not None:
      oprot.writeFieldBegin('principalType', TType.I32, 3)
      oprot.writeI32(self.principalType)
      oprot.writeFieldEnd()
    if self.grantInfo is not None:
      oprot.writeFieldBegin('grantInfo', TType.STRUCT, 4)
      self.grantInfo.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class PrivilegeBag:
  """
  Attributes:
   - privileges
  """

  thrift_spec = (
    None, # 0
    (1, TType.LIST, 'privileges', (TType.STRUCT,(HiveObjectPrivilege, HiveObjectPrivilege.thrift_spec)), None, ), # 1
  )

  def __init__(self, privileges=None,):
    self.privileges = privileges

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.LIST:
          self.privileges = []
          (_etype17, _size14) = iprot.readListBegin()
          for _i18 in xrange(_size14):
            _elem19 = HiveObjectPrivilege()
            _elem19.read(iprot)
            self.privileges.append(_elem19)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('PrivilegeBag')
    if self.privileges is not None:
      oprot.writeFieldBegin('privileges', TType.LIST, 1)
      oprot.writeListBegin(TType.STRUCT, len(self.privileges))
      for iter20 in self.privileges:
        iter20.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class PrincipalPrivilegeSet:
  """
  Attributes:
   - userPrivileges
   - groupPrivileges
   - rolePrivileges
  """

  thrift_spec = (
    None, # 0
    (1, TType.MAP, 'userPrivileges', (TType.STRING,None,TType.LIST,(TType.STRUCT,(PrivilegeGrantInfo, PrivilegeGrantInfo.thrift_spec))), None, ), # 1
    (2, TType.MAP, 'groupPrivileges', (TType.STRING,None,TType.LIST,(TType.STRUCT,(PrivilegeGrantInfo, PrivilegeGrantInfo.thrift_spec))), None, ), # 2
    (3, TType.MAP, 'rolePrivileges', (TType.STRING,None,TType.LIST,(TType.STRUCT,(PrivilegeGrantInfo, PrivilegeGrantInfo.thrift_spec))), None, ), # 3
  )

  def __init__(self, userPrivileges=None, groupPrivileges=None, rolePrivileges=None,):
    self.userPrivileges = userPrivileges
    self.groupPrivileges = groupPrivileges
    self.rolePrivileges = rolePrivileges

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.MAP:
          self.userPrivileges = {}
          (_ktype22, _vtype23, _size21 ) = iprot.readMapBegin() 
          for _i25 in xrange(_size21):
            _key26 = iprot.readString();
            _val27 = []
            (_etype31, _size28) = iprot.readListBegin()
            for _i32 in xrange(_size28):
              _elem33 = PrivilegeGrantInfo()
              _elem33.read(iprot)
              _val27.append(_elem33)
            iprot.readListEnd()
            self.userPrivileges[_key26] = _val27
          iprot.readMapEnd()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.MAP:
          self.groupPrivileges = {}
          (_ktype35, _vtype36, _size34 ) = iprot.readMapBegin() 
          for _i38 in xrange(_size34):
            _key39 = iprot.readString();
            _val40 = []
            (_etype44, _size41) = iprot.readListBegin()
            for _i45 in xrange(_size41):
              _elem46 = PrivilegeGrantInfo()
              _elem46.read(iprot)
              _val40.append(_elem46)
            iprot.readListEnd()
            self.groupPrivileges[_key39] = _val40
          iprot.readMapEnd()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.MAP:
          self.rolePrivileges = {}
          (_ktype48, _vtype49, _size47 ) = iprot.readMapBegin() 
          for _i51 in xrange(_size47):
            _key52 = iprot.readString();
            _val53 = []
            (_etype57, _size54) = iprot.readListBegin()
            for _i58 in xrange(_size54):
              _elem59 = PrivilegeGrantInfo()
              _elem59.read(iprot)
              _val53.append(_elem59)
            iprot.readListEnd()
            self.rolePrivileges[_key52] = _val53
          iprot.readMapEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('PrincipalPrivilegeSet')
    if self.userPrivileges is not None:
      oprot.writeFieldBegin('userPrivileges', TType.MAP, 1)
      oprot.writeMapBegin(TType.STRING, TType.LIST, len(self.userPrivileges))
      for kiter60,viter61 in self.userPrivileges.items():
        oprot.writeString(kiter60)
        oprot.writeListBegin(TType.STRUCT, len(viter61))
        for iter62 in viter61:
          iter62.write(oprot)
        oprot.writeListEnd()
      oprot.writeMapEnd()
      oprot.writeFieldEnd()
    if self.groupPrivileges is not None:
      oprot.writeFieldBegin('groupPrivileges', TType.MAP, 2)
      oprot.writeMapBegin(TType.STRING, TType.LIST, len(self.groupPrivileges))
      for kiter63,viter64 in self.groupPrivileges.items():
        oprot.writeString(kiter63)
        oprot.writeListBegin(TType.STRUCT, len(viter64))
        for iter65 in viter64:
          iter65.write(oprot)
        oprot.writeListEnd()
      oprot.writeMapEnd()
      oprot.writeFieldEnd()
    if self.rolePrivileges is not None:
      oprot.writeFieldBegin('rolePrivileges', TType.MAP, 3)
      oprot.writeMapBegin(TType.STRING, TType.LIST, len(self.rolePrivileges))
      for kiter66,viter67 in self.rolePrivileges.items():
        oprot.writeString(kiter66)
        oprot.writeListBegin(TType.STRUCT, len(viter67))
        for iter68 in viter67:
          iter68.write(oprot)
        oprot.writeListEnd()
      oprot.writeMapEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class Role:
  """
  Attributes:
   - roleName
   - createTime
   - ownerName
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'roleName', None, None, ), # 1
    (2, TType.I32, 'createTime', None, None, ), # 2
    (3, TType.STRING, 'ownerName', None, None, ), # 3
  )

  def __init__(self, roleName=None, createTime=None, ownerName=None,):
    self.roleName = roleName
    self.createTime = createTime
    self.ownerName = ownerName

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.roleName = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I32:
          self.createTime = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRING:
          self.ownerName = iprot.readString();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('Role')
    if self.roleName is not None:
      oprot.writeFieldBegin('roleName', TType.STRING, 1)
      oprot.writeString(self.roleName)
      oprot.writeFieldEnd()
    if self.createTime is not None:
      oprot.writeFieldBegin('createTime', TType.I32, 2)
      oprot.writeI32(self.createTime)
      oprot.writeFieldEnd()
    if self.ownerName is not None:
      oprot.writeFieldBegin('ownerName', TType.STRING, 3)
      oprot.writeString(self.ownerName)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class User:
  """
  Attributes:
   - userName
   - password
   - createTime
   - ownerName
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'userName', None, None, ), # 1
    (2, TType.STRING, 'password', None, None, ), # 2
    (3, TType.I64, 'createTime', None, None, ), # 3
    (4, TType.STRING, 'ownerName', None, None, ), # 4
  )

  def __init__(self, userName=None, password=None, createTime=None, ownerName=None,):
    self.userName = userName
    self.password = password
    self.createTime = createTime
    self.ownerName = ownerName

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.userName = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.password = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.I64:
          self.createTime = iprot.readI64();
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRING:
          self.ownerName = iprot.readString();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('User')
    if self.userName is not None:
      oprot.writeFieldBegin('userName', TType.STRING, 1)
      oprot.writeString(self.userName)
      oprot.writeFieldEnd()
    if self.password is not None:
      oprot.writeFieldBegin('password', TType.STRING, 2)
      oprot.writeString(self.password)
      oprot.writeFieldEnd()
    if self.createTime is not None:
      oprot.writeFieldBegin('createTime', TType.I64, 3)
      oprot.writeI64(self.createTime)
      oprot.writeFieldEnd()
    if self.ownerName is not None:
      oprot.writeFieldBegin('ownerName', TType.STRING, 4)
      oprot.writeString(self.ownerName)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class Node:
  """
  Attributes:
   - node_name
   - ips
   - status
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'node_name', None, None, ), # 1
    (2, TType.LIST, 'ips', (TType.STRING,None), None, ), # 2
    (3, TType.I32, 'status', None, None, ), # 3
  )

  def __init__(self, node_name=None, ips=None, status=None,):
    self.node_name = node_name
    self.ips = ips
    self.status = status

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.node_name = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.LIST:
          self.ips = []
          (_etype72, _size69) = iprot.readListBegin()
          for _i73 in xrange(_size69):
            _elem74 = iprot.readString();
            self.ips.append(_elem74)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.I32:
          self.status = iprot.readI32();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('Node')
    if self.node_name is not None:
      oprot.writeFieldBegin('node_name', TType.STRING, 1)
      oprot.writeString(self.node_name)
      oprot.writeFieldEnd()
    if self.ips is not None:
      oprot.writeFieldBegin('ips', TType.LIST, 2)
      oprot.writeListBegin(TType.STRING, len(self.ips))
      for iter75 in self.ips:
        oprot.writeString(iter75)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.status is not None:
      oprot.writeFieldBegin('status', TType.I32, 3)
      oprot.writeI32(self.status)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class NodeGroup:
  """
  Attributes:
   - node_group_name
   - comment
   - status
   - nodes
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'node_group_name', None, None, ), # 1
    (2, TType.STRING, 'comment', None, None, ), # 2
    (3, TType.I32, 'status', None, None, ), # 3
    (4, TType.SET, 'nodes', (TType.STRUCT,(Node, Node.thrift_spec)), None, ), # 4
  )

  def __init__(self, node_group_name=None, comment=None, status=None, nodes=None,):
    self.node_group_name = node_group_name
    self.comment = comment
    self.status = status
    self.nodes = nodes

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.node_group_name = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.comment = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.I32:
          self.status = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.SET:
          self.nodes = set()
          (_etype79, _size76) = iprot.readSetBegin()
          for _i80 in xrange(_size76):
            _elem81 = Node()
            _elem81.read(iprot)
            self.nodes.add(_elem81)
          iprot.readSetEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('NodeGroup')
    if self.node_group_name is not None:
      oprot.writeFieldBegin('node_group_name', TType.STRING, 1)
      oprot.writeString(self.node_group_name)
      oprot.writeFieldEnd()
    if self.comment is not None:
      oprot.writeFieldBegin('comment', TType.STRING, 2)
      oprot.writeString(self.comment)
      oprot.writeFieldEnd()
    if self.status is not None:
      oprot.writeFieldBegin('status', TType.I32, 3)
      oprot.writeI32(self.status)
      oprot.writeFieldEnd()
    if self.nodes is not None:
      oprot.writeFieldBegin('nodes', TType.SET, 4)
      oprot.writeSetBegin(TType.STRUCT, len(self.nodes))
      for iter82 in self.nodes:
        iter82.write(oprot)
      oprot.writeSetEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class Database:
  """
  Attributes:
   - name
   - description
   - locationUri
   - parameters
   - privileges
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'name', None, None, ), # 1
    (2, TType.STRING, 'description', None, None, ), # 2
    (3, TType.STRING, 'locationUri', None, None, ), # 3
    (4, TType.MAP, 'parameters', (TType.STRING,None,TType.STRING,None), None, ), # 4
    (5, TType.STRUCT, 'privileges', (PrincipalPrivilegeSet, PrincipalPrivilegeSet.thrift_spec), None, ), # 5
  )

  def __init__(self, name=None, description=None, locationUri=None, parameters=None, privileges=None,):
    self.name = name
    self.description = description
    self.locationUri = locationUri
    self.parameters = parameters
    self.privileges = privileges

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.name = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.description = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRING:
          self.locationUri = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.MAP:
          self.parameters = {}
          (_ktype84, _vtype85, _size83 ) = iprot.readMapBegin() 
          for _i87 in xrange(_size83):
            _key88 = iprot.readString();
            _val89 = iprot.readString();
            self.parameters[_key88] = _val89
          iprot.readMapEnd()
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.STRUCT:
          self.privileges = PrincipalPrivilegeSet()
          self.privileges.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('Database')
    if self.name is not None:
      oprot.writeFieldBegin('name', TType.STRING, 1)
      oprot.writeString(self.name)
      oprot.writeFieldEnd()
    if self.description is not None:
      oprot.writeFieldBegin('description', TType.STRING, 2)
      oprot.writeString(self.description)
      oprot.writeFieldEnd()
    if self.locationUri is not None:
      oprot.writeFieldBegin('locationUri', TType.STRING, 3)
      oprot.writeString(self.locationUri)
      oprot.writeFieldEnd()
    if self.parameters is not None:
      oprot.writeFieldBegin('parameters', TType.MAP, 4)
      oprot.writeMapBegin(TType.STRING, TType.STRING, len(self.parameters))
      for kiter90,viter91 in self.parameters.items():
        oprot.writeString(kiter90)
        oprot.writeString(viter91)
      oprot.writeMapEnd()
      oprot.writeFieldEnd()
    if self.privileges is not None:
      oprot.writeFieldBegin('privileges', TType.STRUCT, 5)
      self.privileges.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class SerDeInfo:
  """
  Attributes:
   - name
   - serializationLib
   - parameters
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'name', None, None, ), # 1
    (2, TType.STRING, 'serializationLib', None, None, ), # 2
    (3, TType.MAP, 'parameters', (TType.STRING,None,TType.STRING,None), None, ), # 3
  )

  def __init__(self, name=None, serializationLib=None, parameters=None,):
    self.name = name
    self.serializationLib = serializationLib
    self.parameters = parameters

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.name = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.serializationLib = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.MAP:
          self.parameters = {}
          (_ktype93, _vtype94, _size92 ) = iprot.readMapBegin() 
          for _i96 in xrange(_size92):
            _key97 = iprot.readString();
            _val98 = iprot.readString();
            self.parameters[_key97] = _val98
          iprot.readMapEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('SerDeInfo')
    if self.name is not None:
      oprot.writeFieldBegin('name', TType.STRING, 1)
      oprot.writeString(self.name)
      oprot.writeFieldEnd()
    if self.serializationLib is not None:
      oprot.writeFieldBegin('serializationLib', TType.STRING, 2)
      oprot.writeString(self.serializationLib)
      oprot.writeFieldEnd()
    if self.parameters is not None:
      oprot.writeFieldBegin('parameters', TType.MAP, 3)
      oprot.writeMapBegin(TType.STRING, TType.STRING, len(self.parameters))
      for kiter99,viter100 in self.parameters.items():
        oprot.writeString(kiter99)
        oprot.writeString(viter100)
      oprot.writeMapEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class Order:
  """
  Attributes:
   - col
   - order
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'col', None, None, ), # 1
    (2, TType.I32, 'order', None, None, ), # 2
  )

  def __init__(self, col=None, order=None,):
    self.col = col
    self.order = order

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.col = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I32:
          self.order = iprot.readI32();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('Order')
    if self.col is not None:
      oprot.writeFieldBegin('col', TType.STRING, 1)
      oprot.writeString(self.col)
      oprot.writeFieldEnd()
    if self.order is not None:
      oprot.writeFieldBegin('order', TType.I32, 2)
      oprot.writeI32(self.order)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class SkewedInfo:
  """
  Attributes:
   - skewedColNames
   - skewedColValues
   - skewedColValueLocationMaps
  """

  thrift_spec = (
    None, # 0
    (1, TType.LIST, 'skewedColNames', (TType.STRING,None), None, ), # 1
    (2, TType.LIST, 'skewedColValues', (TType.LIST,(TType.STRING,None)), None, ), # 2
    (3, TType.MAP, 'skewedColValueLocationMaps', (TType.LIST,(TType.STRING,None),TType.STRING,None), None, ), # 3
  )

  def __init__(self, skewedColNames=None, skewedColValues=None, skewedColValueLocationMaps=None,):
    self.skewedColNames = skewedColNames
    self.skewedColValues = skewedColValues
    self.skewedColValueLocationMaps = skewedColValueLocationMaps

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.LIST:
          self.skewedColNames = []
          (_etype104, _size101) = iprot.readListBegin()
          for _i105 in xrange(_size101):
            _elem106 = iprot.readString();
            self.skewedColNames.append(_elem106)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.LIST:
          self.skewedColValues = []
          (_etype110, _size107) = iprot.readListBegin()
          for _i111 in xrange(_size107):
            _elem112 = []
            (_etype116, _size113) = iprot.readListBegin()
            for _i117 in xrange(_size113):
              _elem118 = iprot.readString();
              _elem112.append(_elem118)
            iprot.readListEnd()
            self.skewedColValues.append(_elem112)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.MAP:
          self.skewedColValueLocationMaps = {}
          (_ktype120, _vtype121, _size119 ) = iprot.readMapBegin() 
          for _i123 in xrange(_size119):
            _key124 = []
            (_etype129, _size126) = iprot.readListBegin()
            for _i130 in xrange(_size126):
              _elem131 = iprot.readString();
              _key124.append(_elem131)
            iprot.readListEnd()
            _val125 = iprot.readString();
            self.skewedColValueLocationMaps[_key124] = _val125
          iprot.readMapEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('SkewedInfo')
    if self.skewedColNames is not None:
      oprot.writeFieldBegin('skewedColNames', TType.LIST, 1)
      oprot.writeListBegin(TType.STRING, len(self.skewedColNames))
      for iter132 in self.skewedColNames:
        oprot.writeString(iter132)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.skewedColValues is not None:
      oprot.writeFieldBegin('skewedColValues', TType.LIST, 2)
      oprot.writeListBegin(TType.LIST, len(self.skewedColValues))
      for iter133 in self.skewedColValues:
        oprot.writeListBegin(TType.STRING, len(iter133))
        for iter134 in iter133:
          oprot.writeString(iter134)
        oprot.writeListEnd()
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.skewedColValueLocationMaps is not None:
      oprot.writeFieldBegin('skewedColValueLocationMaps', TType.MAP, 3)
      oprot.writeMapBegin(TType.LIST, TType.STRING, len(self.skewedColValueLocationMaps))
      for kiter135,viter136 in self.skewedColValueLocationMaps.items():
        oprot.writeListBegin(TType.STRING, len(kiter135))
        for iter137 in kiter135:
          oprot.writeString(iter137)
        oprot.writeListEnd()
        oprot.writeString(viter136)
      oprot.writeMapEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class StorageDescriptor:
  """
  Attributes:
   - cols
   - location
   - inputFormat
   - outputFormat
   - compressed
   - numBuckets
   - serdeInfo
   - bucketCols
   - sortCols
   - parameters
   - skewedInfo
   - storedAsSubDirectories
  """

  thrift_spec = (
    None, # 0
    (1, TType.LIST, 'cols', (TType.STRUCT,(FieldSchema, FieldSchema.thrift_spec)), None, ), # 1
    (2, TType.STRING, 'location', None, None, ), # 2
    (3, TType.STRING, 'inputFormat', None, None, ), # 3
    (4, TType.STRING, 'outputFormat', None, None, ), # 4
    (5, TType.BOOL, 'compressed', None, None, ), # 5
    (6, TType.I32, 'numBuckets', None, None, ), # 6
    (7, TType.STRUCT, 'serdeInfo', (SerDeInfo, SerDeInfo.thrift_spec), None, ), # 7
    (8, TType.LIST, 'bucketCols', (TType.STRING,None), None, ), # 8
    (9, TType.LIST, 'sortCols', (TType.STRUCT,(Order, Order.thrift_spec)), None, ), # 9
    (10, TType.MAP, 'parameters', (TType.STRING,None,TType.STRING,None), None, ), # 10
    (11, TType.STRUCT, 'skewedInfo', (SkewedInfo, SkewedInfo.thrift_spec), None, ), # 11
    (12, TType.BOOL, 'storedAsSubDirectories', None, None, ), # 12
  )

  def __init__(self, cols=None, location=None, inputFormat=None, outputFormat=None, compressed=None, numBuckets=None, serdeInfo=None, bucketCols=None, sortCols=None, parameters=None, skewedInfo=None, storedAsSubDirectories=None,):
    self.cols = cols
    self.location = location
    self.inputFormat = inputFormat
    self.outputFormat = outputFormat
    self.compressed = compressed
    self.numBuckets = numBuckets
    self.serdeInfo = serdeInfo
    self.bucketCols = bucketCols
    self.sortCols = sortCols
    self.parameters = parameters
    self.skewedInfo = skewedInfo
    self.storedAsSubDirectories = storedAsSubDirectories

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.LIST:
          self.cols = []
          (_etype141, _size138) = iprot.readListBegin()
          for _i142 in xrange(_size138):
            _elem143 = FieldSchema()
            _elem143.read(iprot)
            self.cols.append(_elem143)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.location = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRING:
          self.inputFormat = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRING:
          self.outputFormat = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.BOOL:
          self.compressed = iprot.readBool();
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.I32:
          self.numBuckets = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 7:
        if ftype == TType.STRUCT:
          self.serdeInfo = SerDeInfo()
          self.serdeInfo.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 8:
        if ftype == TType.LIST:
          self.bucketCols = []
          (_etype147, _size144) = iprot.readListBegin()
          for _i148 in xrange(_size144):
            _elem149 = iprot.readString();
            self.bucketCols.append(_elem149)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 9:
        if ftype == TType.LIST:
          self.sortCols = []
          (_etype153, _size150) = iprot.readListBegin()
          for _i154 in xrange(_size150):
            _elem155 = Order()
            _elem155.read(iprot)
            self.sortCols.append(_elem155)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 10:
        if ftype == TType.MAP:
          self.parameters = {}
          (_ktype157, _vtype158, _size156 ) = iprot.readMapBegin() 
          for _i160 in xrange(_size156):
            _key161 = iprot.readString();
            _val162 = iprot.readString();
            self.parameters[_key161] = _val162
          iprot.readMapEnd()
        else:
          iprot.skip(ftype)
      elif fid == 11:
        if ftype == TType.STRUCT:
          self.skewedInfo = SkewedInfo()
          self.skewedInfo.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 12:
        if ftype == TType.BOOL:
          self.storedAsSubDirectories = iprot.readBool();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('StorageDescriptor')
    if self.cols is not None:
      oprot.writeFieldBegin('cols', TType.LIST, 1)
      oprot.writeListBegin(TType.STRUCT, len(self.cols))
      for iter163 in self.cols:
        iter163.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.location is not None:
      oprot.writeFieldBegin('location', TType.STRING, 2)
      oprot.writeString(self.location)
      oprot.writeFieldEnd()
    if self.inputFormat is not None:
      oprot.writeFieldBegin('inputFormat', TType.STRING, 3)
      oprot.writeString(self.inputFormat)
      oprot.writeFieldEnd()
    if self.outputFormat is not None:
      oprot.writeFieldBegin('outputFormat', TType.STRING, 4)
      oprot.writeString(self.outputFormat)
      oprot.writeFieldEnd()
    if self.compressed is not None:
      oprot.writeFieldBegin('compressed', TType.BOOL, 5)
      oprot.writeBool(self.compressed)
      oprot.writeFieldEnd()
    if self.numBuckets is not None:
      oprot.writeFieldBegin('numBuckets', TType.I32, 6)
      oprot.writeI32(self.numBuckets)
      oprot.writeFieldEnd()
    if self.serdeInfo is not None:
      oprot.writeFieldBegin('serdeInfo', TType.STRUCT, 7)
      self.serdeInfo.write(oprot)
      oprot.writeFieldEnd()
    if self.bucketCols is not None:
      oprot.writeFieldBegin('bucketCols', TType.LIST, 8)
      oprot.writeListBegin(TType.STRING, len(self.bucketCols))
      for iter164 in self.bucketCols:
        oprot.writeString(iter164)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.sortCols is not None:
      oprot.writeFieldBegin('sortCols', TType.LIST, 9)
      oprot.writeListBegin(TType.STRUCT, len(self.sortCols))
      for iter165 in self.sortCols:
        iter165.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.parameters is not None:
      oprot.writeFieldBegin('parameters', TType.MAP, 10)
      oprot.writeMapBegin(TType.STRING, TType.STRING, len(self.parameters))
      for kiter166,viter167 in self.parameters.items():
        oprot.writeString(kiter166)
        oprot.writeString(viter167)
      oprot.writeMapEnd()
      oprot.writeFieldEnd()
    if self.skewedInfo is not None:
      oprot.writeFieldBegin('skewedInfo', TType.STRUCT, 11)
      self.skewedInfo.write(oprot)
      oprot.writeFieldEnd()
    if self.storedAsSubDirectories is not None:
      oprot.writeFieldBegin('storedAsSubDirectories', TType.BOOL, 12)
      oprot.writeBool(self.storedAsSubDirectories)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class Subpartition:
  """
  Attributes:
   - values
   - dbName
   - tableName
   - createTime
   - lastAccessTime
   - sd
   - parameters
   - files
   - partitionName
   - version
   - privileges
  """

  thrift_spec = (
    None, # 0
    (1, TType.LIST, 'values', (TType.STRING,None), None, ), # 1
    (2, TType.STRING, 'dbName', None, None, ), # 2
    (3, TType.STRING, 'tableName', None, None, ), # 3
    (4, TType.I32, 'createTime', None, None, ), # 4
    (5, TType.I32, 'lastAccessTime', None, None, ), # 5
    (6, TType.STRUCT, 'sd', (StorageDescriptor, StorageDescriptor.thrift_spec), None, ), # 6
    (7, TType.MAP, 'parameters', (TType.STRING,None,TType.STRING,None), None, ), # 7
    (8, TType.LIST, 'files', (TType.I64,None), None, ), # 8
    (9, TType.STRING, 'partitionName', None, None, ), # 9
    (10, TType.I32, 'version', None, None, ), # 10
    (11, TType.STRUCT, 'privileges', (PrincipalPrivilegeSet, PrincipalPrivilegeSet.thrift_spec), None, ), # 11
  )

  def __init__(self, values=None, dbName=None, tableName=None, createTime=None, lastAccessTime=None, sd=None, parameters=None, files=None, partitionName=None, version=None, privileges=None,):
    self.values = values
    self.dbName = dbName
    self.tableName = tableName
    self.createTime = createTime
    self.lastAccessTime = lastAccessTime
    self.sd = sd
    self.parameters = parameters
    self.files = files
    self.partitionName = partitionName
    self.version = version
    self.privileges = privileges

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.LIST:
          self.values = []
          (_etype171, _size168) = iprot.readListBegin()
          for _i172 in xrange(_size168):
            _elem173 = iprot.readString();
            self.values.append(_elem173)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.dbName = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRING:
          self.tableName = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.I32:
          self.createTime = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.I32:
          self.lastAccessTime = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.STRUCT:
          self.sd = StorageDescriptor()
          self.sd.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 7:
        if ftype == TType.MAP:
          self.parameters = {}
          (_ktype175, _vtype176, _size174 ) = iprot.readMapBegin() 
          for _i178 in xrange(_size174):
            _key179 = iprot.readString();
            _val180 = iprot.readString();
            self.parameters[_key179] = _val180
          iprot.readMapEnd()
        else:
          iprot.skip(ftype)
      elif fid == 8:
        if ftype == TType.LIST:
          self.files = []
          (_etype184, _size181) = iprot.readListBegin()
          for _i185 in xrange(_size181):
            _elem186 = iprot.readI64();
            self.files.append(_elem186)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 9:
        if ftype == TType.STRING:
          self.partitionName = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 10:
        if ftype == TType.I32:
          self.version = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 11:
        if ftype == TType.STRUCT:
          self.privileges = PrincipalPrivilegeSet()
          self.privileges.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('Subpartition')
    if self.values is not None:
      oprot.writeFieldBegin('values', TType.LIST, 1)
      oprot.writeListBegin(TType.STRING, len(self.values))
      for iter187 in self.values:
        oprot.writeString(iter187)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.dbName is not None:
      oprot.writeFieldBegin('dbName', TType.STRING, 2)
      oprot.writeString(self.dbName)
      oprot.writeFieldEnd()
    if self.tableName is not None:
      oprot.writeFieldBegin('tableName', TType.STRING, 3)
      oprot.writeString(self.tableName)
      oprot.writeFieldEnd()
    if self.createTime is not None:
      oprot.writeFieldBegin('createTime', TType.I32, 4)
      oprot.writeI32(self.createTime)
      oprot.writeFieldEnd()
    if self.lastAccessTime is not None:
      oprot.writeFieldBegin('lastAccessTime', TType.I32, 5)
      oprot.writeI32(self.lastAccessTime)
      oprot.writeFieldEnd()
    if self.sd is not None:
      oprot.writeFieldBegin('sd', TType.STRUCT, 6)
      self.sd.write(oprot)
      oprot.writeFieldEnd()
    if self.parameters is not None:
      oprot.writeFieldBegin('parameters', TType.MAP, 7)
      oprot.writeMapBegin(TType.STRING, TType.STRING, len(self.parameters))
      for kiter188,viter189 in self.parameters.items():
        oprot.writeString(kiter188)
        oprot.writeString(viter189)
      oprot.writeMapEnd()
      oprot.writeFieldEnd()
    if self.files is not None:
      oprot.writeFieldBegin('files', TType.LIST, 8)
      oprot.writeListBegin(TType.I64, len(self.files))
      for iter190 in self.files:
        oprot.writeI64(iter190)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.partitionName is not None:
      oprot.writeFieldBegin('partitionName', TType.STRING, 9)
      oprot.writeString(self.partitionName)
      oprot.writeFieldEnd()
    if self.version is not None:
      oprot.writeFieldBegin('version', TType.I32, 10)
      oprot.writeI32(self.version)
      oprot.writeFieldEnd()
    if self.privileges is not None:
      oprot.writeFieldBegin('privileges', TType.STRUCT, 11)
      self.privileges.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class Partition:
  """
  Attributes:
   - values
   - dbName
   - tableName
   - createTime
   - lastAccessTime
   - sd
   - parameters
   - files
   - partitionName
   - subpartitions
   - version
   - privileges
  """

  thrift_spec = (
    None, # 0
    (1, TType.LIST, 'values', (TType.STRING,None), None, ), # 1
    (2, TType.STRING, 'dbName', None, None, ), # 2
    (3, TType.STRING, 'tableName', None, None, ), # 3
    (4, TType.I32, 'createTime', None, None, ), # 4
    (5, TType.I32, 'lastAccessTime', None, None, ), # 5
    (6, TType.STRUCT, 'sd', (StorageDescriptor, StorageDescriptor.thrift_spec), None, ), # 6
    (7, TType.MAP, 'parameters', (TType.STRING,None,TType.STRING,None), None, ), # 7
    (8, TType.LIST, 'files', (TType.I64,None), None, ), # 8
    (9, TType.STRING, 'partitionName', None, None, ), # 9
    (10, TType.LIST, 'subpartitions', (TType.STRUCT,(Subpartition, Subpartition.thrift_spec)), None, ), # 10
    (11, TType.I32, 'version', None, None, ), # 11
    (12, TType.STRUCT, 'privileges', (PrincipalPrivilegeSet, PrincipalPrivilegeSet.thrift_spec), None, ), # 12
  )

  def __init__(self, values=None, dbName=None, tableName=None, createTime=None, lastAccessTime=None, sd=None, parameters=None, files=None, partitionName=None, subpartitions=None, version=None, privileges=None,):
    self.values = values
    self.dbName = dbName
    self.tableName = tableName
    self.createTime = createTime
    self.lastAccessTime = lastAccessTime
    self.sd = sd
    self.parameters = parameters
    self.files = files
    self.partitionName = partitionName
    self.subpartitions = subpartitions
    self.version = version
    self.privileges = privileges

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.LIST:
          self.values = []
          (_etype194, _size191) = iprot.readListBegin()
          for _i195 in xrange(_size191):
            _elem196 = iprot.readString();
            self.values.append(_elem196)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.dbName = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRING:
          self.tableName = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.I32:
          self.createTime = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.I32:
          self.lastAccessTime = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.STRUCT:
          self.sd = StorageDescriptor()
          self.sd.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 7:
        if ftype == TType.MAP:
          self.parameters = {}
          (_ktype198, _vtype199, _size197 ) = iprot.readMapBegin() 
          for _i201 in xrange(_size197):
            _key202 = iprot.readString();
            _val203 = iprot.readString();
            self.parameters[_key202] = _val203
          iprot.readMapEnd()
        else:
          iprot.skip(ftype)
      elif fid == 8:
        if ftype == TType.LIST:
          self.files = []
          (_etype207, _size204) = iprot.readListBegin()
          for _i208 in xrange(_size204):
            _elem209 = iprot.readI64();
            self.files.append(_elem209)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 9:
        if ftype == TType.STRING:
          self.partitionName = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 10:
        if ftype == TType.LIST:
          self.subpartitions = []
          (_etype213, _size210) = iprot.readListBegin()
          for _i214 in xrange(_size210):
            _elem215 = Subpartition()
            _elem215.read(iprot)
            self.subpartitions.append(_elem215)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 11:
        if ftype == TType.I32:
          self.version = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 12:
        if ftype == TType.STRUCT:
          self.privileges = PrincipalPrivilegeSet()
          self.privileges.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('Partition')
    if self.values is not None:
      oprot.writeFieldBegin('values', TType.LIST, 1)
      oprot.writeListBegin(TType.STRING, len(self.values))
      for iter216 in self.values:
        oprot.writeString(iter216)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.dbName is not None:
      oprot.writeFieldBegin('dbName', TType.STRING, 2)
      oprot.writeString(self.dbName)
      oprot.writeFieldEnd()
    if self.tableName is not None:
      oprot.writeFieldBegin('tableName', TType.STRING, 3)
      oprot.writeString(self.tableName)
      oprot.writeFieldEnd()
    if self.createTime is not None:
      oprot.writeFieldBegin('createTime', TType.I32, 4)
      oprot.writeI32(self.createTime)
      oprot.writeFieldEnd()
    if self.lastAccessTime is not None:
      oprot.writeFieldBegin('lastAccessTime', TType.I32, 5)
      oprot.writeI32(self.lastAccessTime)
      oprot.writeFieldEnd()
    if self.sd is not None:
      oprot.writeFieldBegin('sd', TType.STRUCT, 6)
      self.sd.write(oprot)
      oprot.writeFieldEnd()
    if self.parameters is not None:
      oprot.writeFieldBegin('parameters', TType.MAP, 7)
      oprot.writeMapBegin(TType.STRING, TType.STRING, len(self.parameters))
      for kiter217,viter218 in self.parameters.items():
        oprot.writeString(kiter217)
        oprot.writeString(viter218)
      oprot.writeMapEnd()
      oprot.writeFieldEnd()
    if self.files is not None:
      oprot.writeFieldBegin('files', TType.LIST, 8)
      oprot.writeListBegin(TType.I64, len(self.files))
      for iter219 in self.files:
        oprot.writeI64(iter219)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.partitionName is not None:
      oprot.writeFieldBegin('partitionName', TType.STRING, 9)
      oprot.writeString(self.partitionName)
      oprot.writeFieldEnd()
    if self.subpartitions is not None:
      oprot.writeFieldBegin('subpartitions', TType.LIST, 10)
      oprot.writeListBegin(TType.STRUCT, len(self.subpartitions))
      for iter220 in self.subpartitions:
        iter220.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.version is not None:
      oprot.writeFieldBegin('version', TType.I32, 11)
      oprot.writeI32(self.version)
      oprot.writeFieldEnd()
    if self.privileges is not None:
      oprot.writeFieldBegin('privileges', TType.STRUCT, 12)
      self.privileges.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class GlobalSchema:
  """
  Attributes:
   - schemaName
   - owner
   - createTime
   - lastAccessTime
   - retention
   - sd
   - parameters
   - viewOriginalText
   - viewExpandedText
   - schemaType
   - privileges
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'schemaName', None, None, ), # 1
    (2, TType.STRING, 'owner', None, None, ), # 2
    (3, TType.I32, 'createTime', None, None, ), # 3
    (4, TType.I32, 'lastAccessTime', None, None, ), # 4
    (5, TType.I32, 'retention', None, None, ), # 5
    (6, TType.STRUCT, 'sd', (StorageDescriptor, StorageDescriptor.thrift_spec), None, ), # 6
    (7, TType.MAP, 'parameters', (TType.STRING,None,TType.STRING,None), None, ), # 7
    (8, TType.STRING, 'viewOriginalText', None, None, ), # 8
    (9, TType.STRING, 'viewExpandedText', None, None, ), # 9
    (10, TType.STRING, 'schemaType', None, None, ), # 10
    (11, TType.STRUCT, 'privileges', (PrincipalPrivilegeSet, PrincipalPrivilegeSet.thrift_spec), None, ), # 11
  )

  def __init__(self, schemaName=None, owner=None, createTime=None, lastAccessTime=None, retention=None, sd=None, parameters=None, viewOriginalText=None, viewExpandedText=None, schemaType=None, privileges=None,):
    self.schemaName = schemaName
    self.owner = owner
    self.createTime = createTime
    self.lastAccessTime = lastAccessTime
    self.retention = retention
    self.sd = sd
    self.parameters = parameters
    self.viewOriginalText = viewOriginalText
    self.viewExpandedText = viewExpandedText
    self.schemaType = schemaType
    self.privileges = privileges

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.schemaName = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.owner = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.I32:
          self.createTime = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.I32:
          self.lastAccessTime = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.I32:
          self.retention = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.STRUCT:
          self.sd = StorageDescriptor()
          self.sd.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 7:
        if ftype == TType.MAP:
          self.parameters = {}
          (_ktype222, _vtype223, _size221 ) = iprot.readMapBegin() 
          for _i225 in xrange(_size221):
            _key226 = iprot.readString();
            _val227 = iprot.readString();
            self.parameters[_key226] = _val227
          iprot.readMapEnd()
        else:
          iprot.skip(ftype)
      elif fid == 8:
        if ftype == TType.STRING:
          self.viewOriginalText = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 9:
        if ftype == TType.STRING:
          self.viewExpandedText = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 10:
        if ftype == TType.STRING:
          self.schemaType = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 11:
        if ftype == TType.STRUCT:
          self.privileges = PrincipalPrivilegeSet()
          self.privileges.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('GlobalSchema')
    if self.schemaName is not None:
      oprot.writeFieldBegin('schemaName', TType.STRING, 1)
      oprot.writeString(self.schemaName)
      oprot.writeFieldEnd()
    if self.owner is not None:
      oprot.writeFieldBegin('owner', TType.STRING, 2)
      oprot.writeString(self.owner)
      oprot.writeFieldEnd()
    if self.createTime is not None:
      oprot.writeFieldBegin('createTime', TType.I32, 3)
      oprot.writeI32(self.createTime)
      oprot.writeFieldEnd()
    if self.lastAccessTime is not None:
      oprot.writeFieldBegin('lastAccessTime', TType.I32, 4)
      oprot.writeI32(self.lastAccessTime)
      oprot.writeFieldEnd()
    if self.retention is not None:
      oprot.writeFieldBegin('retention', TType.I32, 5)
      oprot.writeI32(self.retention)
      oprot.writeFieldEnd()
    if self.sd is not None:
      oprot.writeFieldBegin('sd', TType.STRUCT, 6)
      self.sd.write(oprot)
      oprot.writeFieldEnd()
    if self.parameters is not None:
      oprot.writeFieldBegin('parameters', TType.MAP, 7)
      oprot.writeMapBegin(TType.STRING, TType.STRING, len(self.parameters))
      for kiter228,viter229 in self.parameters.items():
        oprot.writeString(kiter228)
        oprot.writeString(viter229)
      oprot.writeMapEnd()
      oprot.writeFieldEnd()
    if self.viewOriginalText is not None:
      oprot.writeFieldBegin('viewOriginalText', TType.STRING, 8)
      oprot.writeString(self.viewOriginalText)
      oprot.writeFieldEnd()
    if self.viewExpandedText is not None:
      oprot.writeFieldBegin('viewExpandedText', TType.STRING, 9)
      oprot.writeString(self.viewExpandedText)
      oprot.writeFieldEnd()
    if self.schemaType is not None:
      oprot.writeFieldBegin('schemaType', TType.STRING, 10)
      oprot.writeString(self.schemaType)
      oprot.writeFieldEnd()
    if self.privileges is not None:
      oprot.writeFieldBegin('privileges', TType.STRUCT, 11)
      self.privileges.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class Table:
  """
  Attributes:
   - tableName
   - dbName
   - schemaName
   - owner
   - createTime
   - lastAccessTime
   - retention
   - sd
   - partitionKeys
   - parameters
   - viewOriginalText
   - viewExpandedText
   - tableType
   - nodeGroups
   - privileges
   - partitions
   - fileSplitKeys
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'tableName', None, None, ), # 1
    (2, TType.STRING, 'dbName', None, None, ), # 2
    (3, TType.STRING, 'schemaName', None, None, ), # 3
    (4, TType.STRING, 'owner', None, None, ), # 4
    (5, TType.I32, 'createTime', None, None, ), # 5
    (6, TType.I32, 'lastAccessTime', None, None, ), # 6
    (7, TType.I32, 'retention', None, None, ), # 7
    (8, TType.STRUCT, 'sd', (StorageDescriptor, StorageDescriptor.thrift_spec), None, ), # 8
    (9, TType.LIST, 'partitionKeys', (TType.STRUCT,(FieldSchema, FieldSchema.thrift_spec)), None, ), # 9
    (10, TType.MAP, 'parameters', (TType.STRING,None,TType.STRING,None), None, ), # 10
    (11, TType.STRING, 'viewOriginalText', None, None, ), # 11
    (12, TType.STRING, 'viewExpandedText', None, None, ), # 12
    (13, TType.STRING, 'tableType', None, None, ), # 13
    (14, TType.LIST, 'nodeGroups', (TType.STRUCT,(NodeGroup, NodeGroup.thrift_spec)), None, ), # 14
    (15, TType.STRUCT, 'privileges', (PrincipalPrivilegeSet, PrincipalPrivilegeSet.thrift_spec), None, ), # 15
    (16, TType.LIST, 'partitions', (TType.STRUCT,(Partition, Partition.thrift_spec)), None, ), # 16
    (17, TType.LIST, 'fileSplitKeys', (TType.STRUCT,(FieldSchema, FieldSchema.thrift_spec)), None, ), # 17
  )

  def __init__(self, tableName=None, dbName=None, schemaName=None, owner=None, createTime=None, lastAccessTime=None, retention=None, sd=None, partitionKeys=None, parameters=None, viewOriginalText=None, viewExpandedText=None, tableType=None, nodeGroups=None, privileges=None, partitions=None, fileSplitKeys=None,):
    self.tableName = tableName
    self.dbName = dbName
    self.schemaName = schemaName
    self.owner = owner
    self.createTime = createTime
    self.lastAccessTime = lastAccessTime
    self.retention = retention
    self.sd = sd
    self.partitionKeys = partitionKeys
    self.parameters = parameters
    self.viewOriginalText = viewOriginalText
    self.viewExpandedText = viewExpandedText
    self.tableType = tableType
    self.nodeGroups = nodeGroups
    self.privileges = privileges
    self.partitions = partitions
    self.fileSplitKeys = fileSplitKeys

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.tableName = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.dbName = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRING:
          self.schemaName = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRING:
          self.owner = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.I32:
          self.createTime = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.I32:
          self.lastAccessTime = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 7:
        if ftype == TType.I32:
          self.retention = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 8:
        if ftype == TType.STRUCT:
          self.sd = StorageDescriptor()
          self.sd.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 9:
        if ftype == TType.LIST:
          self.partitionKeys = []
          (_etype233, _size230) = iprot.readListBegin()
          for _i234 in xrange(_size230):
            _elem235 = FieldSchema()
            _elem235.read(iprot)
            self.partitionKeys.append(_elem235)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 10:
        if ftype == TType.MAP:
          self.parameters = {}
          (_ktype237, _vtype238, _size236 ) = iprot.readMapBegin() 
          for _i240 in xrange(_size236):
            _key241 = iprot.readString();
            _val242 = iprot.readString();
            self.parameters[_key241] = _val242
          iprot.readMapEnd()
        else:
          iprot.skip(ftype)
      elif fid == 11:
        if ftype == TType.STRING:
          self.viewOriginalText = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 12:
        if ftype == TType.STRING:
          self.viewExpandedText = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 13:
        if ftype == TType.STRING:
          self.tableType = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 14:
        if ftype == TType.LIST:
          self.nodeGroups = []
          (_etype246, _size243) = iprot.readListBegin()
          for _i247 in xrange(_size243):
            _elem248 = NodeGroup()
            _elem248.read(iprot)
            self.nodeGroups.append(_elem248)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 15:
        if ftype == TType.STRUCT:
          self.privileges = PrincipalPrivilegeSet()
          self.privileges.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 16:
        if ftype == TType.LIST:
          self.partitions = []
          (_etype252, _size249) = iprot.readListBegin()
          for _i253 in xrange(_size249):
            _elem254 = Partition()
            _elem254.read(iprot)
            self.partitions.append(_elem254)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 17:
        if ftype == TType.LIST:
          self.fileSplitKeys = []
          (_etype258, _size255) = iprot.readListBegin()
          for _i259 in xrange(_size255):
            _elem260 = FieldSchema()
            _elem260.read(iprot)
            self.fileSplitKeys.append(_elem260)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('Table')
    if self.tableName is not None:
      oprot.writeFieldBegin('tableName', TType.STRING, 1)
      oprot.writeString(self.tableName)
      oprot.writeFieldEnd()
    if self.dbName is not None:
      oprot.writeFieldBegin('dbName', TType.STRING, 2)
      oprot.writeString(self.dbName)
      oprot.writeFieldEnd()
    if self.schemaName is not None:
      oprot.writeFieldBegin('schemaName', TType.STRING, 3)
      oprot.writeString(self.schemaName)
      oprot.writeFieldEnd()
    if self.owner is not None:
      oprot.writeFieldBegin('owner', TType.STRING, 4)
      oprot.writeString(self.owner)
      oprot.writeFieldEnd()
    if self.createTime is not None:
      oprot.writeFieldBegin('createTime', TType.I32, 5)
      oprot.writeI32(self.createTime)
      oprot.writeFieldEnd()
    if self.lastAccessTime is not None:
      oprot.writeFieldBegin('lastAccessTime', TType.I32, 6)
      oprot.writeI32(self.lastAccessTime)
      oprot.writeFieldEnd()
    if self.retention is not None:
      oprot.writeFieldBegin('retention', TType.I32, 7)
      oprot.writeI32(self.retention)
      oprot.writeFieldEnd()
    if self.sd is not None:
      oprot.writeFieldBegin('sd', TType.STRUCT, 8)
      self.sd.write(oprot)
      oprot.writeFieldEnd()
    if self.partitionKeys is not None:
      oprot.writeFieldBegin('partitionKeys', TType.LIST, 9)
      oprot.writeListBegin(TType.STRUCT, len(self.partitionKeys))
      for iter261 in self.partitionKeys:
        iter261.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.parameters is not None:
      oprot.writeFieldBegin('parameters', TType.MAP, 10)
      oprot.writeMapBegin(TType.STRING, TType.STRING, len(self.parameters))
      for kiter262,viter263 in self.parameters.items():
        oprot.writeString(kiter262)
        oprot.writeString(viter263)
      oprot.writeMapEnd()
      oprot.writeFieldEnd()
    if self.viewOriginalText is not None:
      oprot.writeFieldBegin('viewOriginalText', TType.STRING, 11)
      oprot.writeString(self.viewOriginalText)
      oprot.writeFieldEnd()
    if self.viewExpandedText is not None:
      oprot.writeFieldBegin('viewExpandedText', TType.STRING, 12)
      oprot.writeString(self.viewExpandedText)
      oprot.writeFieldEnd()
    if self.tableType is not None:
      oprot.writeFieldBegin('tableType', TType.STRING, 13)
      oprot.writeString(self.tableType)
      oprot.writeFieldEnd()
    if self.nodeGroups is not None:
      oprot.writeFieldBegin('nodeGroups', TType.LIST, 14)
      oprot.writeListBegin(TType.STRUCT, len(self.nodeGroups))
      for iter264 in self.nodeGroups:
        iter264.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.privileges is not None:
      oprot.writeFieldBegin('privileges', TType.STRUCT, 15)
      self.privileges.write(oprot)
      oprot.writeFieldEnd()
    if self.partitions is not None:
      oprot.writeFieldBegin('partitions', TType.LIST, 16)
      oprot.writeListBegin(TType.STRUCT, len(self.partitions))
      for iter265 in self.partitions:
        iter265.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.fileSplitKeys is not None:
      oprot.writeFieldBegin('fileSplitKeys', TType.LIST, 17)
      oprot.writeListBegin(TType.STRUCT, len(self.fileSplitKeys))
      for iter266 in self.fileSplitKeys:
        iter266.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class BusiTypeColumn:
  """
  Attributes:
   - busiType
   - table
   - column
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'busiType', None, None, ), # 1
    (2, TType.STRUCT, 'table', (Table, Table.thrift_spec), None, ), # 2
    (3, TType.STRING, 'column', None, None, ), # 3
  )

  def __init__(self, busiType=None, table=None, column=None,):
    self.busiType = busiType
    self.table = table
    self.column = column

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.busiType = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.table = Table()
          self.table.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRING:
          self.column = iprot.readString();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('BusiTypeColumn')
    if self.busiType is not None:
      oprot.writeFieldBegin('busiType', TType.STRING, 1)
      oprot.writeString(self.busiType)
      oprot.writeFieldEnd()
    if self.table is not None:
      oprot.writeFieldBegin('table', TType.STRUCT, 2)
      self.table.write(oprot)
      oprot.writeFieldEnd()
    if self.column is not None:
      oprot.writeFieldBegin('column', TType.STRING, 3)
      oprot.writeString(self.column)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class BusiTypeDatacenter:
  """
  Attributes:
   - busiType
   - db
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'busiType', None, None, ), # 1
    (2, TType.STRUCT, 'db', (Database, Database.thrift_spec), None, ), # 2
  )

  def __init__(self, busiType=None, db=None,):
    self.busiType = busiType
    self.db = db

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.busiType = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.db = Database()
          self.db.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('BusiTypeDatacenter')
    if self.busiType is not None:
      oprot.writeFieldBegin('busiType', TType.STRING, 1)
      oprot.writeString(self.busiType)
      oprot.writeFieldEnd()
    if self.db is not None:
      oprot.writeFieldBegin('db', TType.STRUCT, 2)
      self.db.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class SplitValue:
  """
  Attributes:
   - splitKeyName
   - level
   - value
   - verison
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'splitKeyName', None, None, ), # 1
    (2, TType.I32, 'level', None, None, ), # 2
    (3, TType.STRING, 'value', None, None, ), # 3
    (4, TType.I64, 'verison', None, None, ), # 4
  )

  def __init__(self, splitKeyName=None, level=None, value=None, verison=None,):
    self.splitKeyName = splitKeyName
    self.level = level
    self.value = value
    self.verison = verison

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.splitKeyName = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I32:
          self.level = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRING:
          self.value = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.I64:
          self.verison = iprot.readI64();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('SplitValue')
    if self.splitKeyName is not None:
      oprot.writeFieldBegin('splitKeyName', TType.STRING, 1)
      oprot.writeString(self.splitKeyName)
      oprot.writeFieldEnd()
    if self.level is not None:
      oprot.writeFieldBegin('level', TType.I32, 2)
      oprot.writeI32(self.level)
      oprot.writeFieldEnd()
    if self.value is not None:
      oprot.writeFieldBegin('value', TType.STRING, 3)
      oprot.writeString(self.value)
      oprot.writeFieldEnd()
    if self.verison is not None:
      oprot.writeFieldBegin('verison', TType.I64, 4)
      oprot.writeI64(self.verison)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class Device:
  """
  Attributes:
   - devid
   - prop
   - node_name
   - status
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'devid', None, None, ), # 1
    (2, TType.I32, 'prop', None, None, ), # 2
    (3, TType.STRING, 'node_name', None, None, ), # 3
    (4, TType.I32, 'status', None, None, ), # 4
  )

  def __init__(self, devid=None, prop=None, node_name=None, status=None,):
    self.devid = devid
    self.prop = prop
    self.node_name = node_name
    self.status = status

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.devid = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I32:
          self.prop = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRING:
          self.node_name = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.I32:
          self.status = iprot.readI32();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('Device')
    if self.devid is not None:
      oprot.writeFieldBegin('devid', TType.STRING, 1)
      oprot.writeString(self.devid)
      oprot.writeFieldEnd()
    if self.prop is not None:
      oprot.writeFieldBegin('prop', TType.I32, 2)
      oprot.writeI32(self.prop)
      oprot.writeFieldEnd()
    if self.node_name is not None:
      oprot.writeFieldBegin('node_name', TType.STRING, 3)
      oprot.writeString(self.node_name)
      oprot.writeFieldEnd()
    if self.status is not None:
      oprot.writeFieldBegin('status', TType.I32, 4)
      oprot.writeI32(self.status)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class SFileLocation:
  """
  Attributes:
   - node_name
   - fid
   - devid
   - location
   - rep_id
   - update_time
   - visit_status
   - digest
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'node_name', None, None, ), # 1
    (2, TType.I64, 'fid', None, None, ), # 2
    (3, TType.STRING, 'devid', None, None, ), # 3
    (4, TType.STRING, 'location', None, None, ), # 4
    (5, TType.I32, 'rep_id', None, None, ), # 5
    (6, TType.I64, 'update_time', None, None, ), # 6
    (7, TType.I32, 'visit_status', None, None, ), # 7
    (8, TType.STRING, 'digest', None, None, ), # 8
  )

  def __init__(self, node_name=None, fid=None, devid=None, location=None, rep_id=None, update_time=None, visit_status=None, digest=None,):
    self.node_name = node_name
    self.fid = fid
    self.devid = devid
    self.location = location
    self.rep_id = rep_id
    self.update_time = update_time
    self.visit_status = visit_status
    self.digest = digest

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.node_name = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I64:
          self.fid = iprot.readI64();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRING:
          self.devid = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRING:
          self.location = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.I32:
          self.rep_id = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.I64:
          self.update_time = iprot.readI64();
        else:
          iprot.skip(ftype)
      elif fid == 7:
        if ftype == TType.I32:
          self.visit_status = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 8:
        if ftype == TType.STRING:
          self.digest = iprot.readString();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('SFileLocation')
    if self.node_name is not None:
      oprot.writeFieldBegin('node_name', TType.STRING, 1)
      oprot.writeString(self.node_name)
      oprot.writeFieldEnd()
    if self.fid is not None:
      oprot.writeFieldBegin('fid', TType.I64, 2)
      oprot.writeI64(self.fid)
      oprot.writeFieldEnd()
    if self.devid is not None:
      oprot.writeFieldBegin('devid', TType.STRING, 3)
      oprot.writeString(self.devid)
      oprot.writeFieldEnd()
    if self.location is not None:
      oprot.writeFieldBegin('location', TType.STRING, 4)
      oprot.writeString(self.location)
      oprot.writeFieldEnd()
    if self.rep_id is not None:
      oprot.writeFieldBegin('rep_id', TType.I32, 5)
      oprot.writeI32(self.rep_id)
      oprot.writeFieldEnd()
    if self.update_time is not None:
      oprot.writeFieldBegin('update_time', TType.I64, 6)
      oprot.writeI64(self.update_time)
      oprot.writeFieldEnd()
    if self.visit_status is not None:
      oprot.writeFieldBegin('visit_status', TType.I32, 7)
      oprot.writeI32(self.visit_status)
      oprot.writeFieldEnd()
    if self.digest is not None:
      oprot.writeFieldBegin('digest', TType.STRING, 8)
      oprot.writeString(self.digest)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class SFile:
  """
  Attributes:
   - fid
   - dbName
   - tableName
   - store_status
   - rep_nr
   - digest
   - record_nr
   - all_record_nr
   - locations
   - length
   - values
  """

  thrift_spec = (
    None, # 0
    (1, TType.I64, 'fid', None, None, ), # 1
    (2, TType.STRING, 'dbName', None, None, ), # 2
    (3, TType.STRING, 'tableName', None, None, ), # 3
    (4, TType.I32, 'store_status', None, None, ), # 4
    (5, TType.I32, 'rep_nr', None, None, ), # 5
    (6, TType.STRING, 'digest', None, None, ), # 6
    (7, TType.I64, 'record_nr', None, None, ), # 7
    (8, TType.I64, 'all_record_nr', None, None, ), # 8
    (9, TType.LIST, 'locations', (TType.STRUCT,(SFileLocation, SFileLocation.thrift_spec)), None, ), # 9
    (10, TType.I64, 'length', None, None, ), # 10
    (11, TType.LIST, 'values', (TType.STRUCT,(SplitValue, SplitValue.thrift_spec)), None, ), # 11
  )

  def __init__(self, fid=None, dbName=None, tableName=None, store_status=None, rep_nr=None, digest=None, record_nr=None, all_record_nr=None, locations=None, length=None, values=None,):
    self.fid = fid
    self.dbName = dbName
    self.tableName = tableName
    self.store_status = store_status
    self.rep_nr = rep_nr
    self.digest = digest
    self.record_nr = record_nr
    self.all_record_nr = all_record_nr
    self.locations = locations
    self.length = length
    self.values = values

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I64:
          self.fid = iprot.readI64();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.dbName = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRING:
          self.tableName = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.I32:
          self.store_status = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.I32:
          self.rep_nr = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.STRING:
          self.digest = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 7:
        if ftype == TType.I64:
          self.record_nr = iprot.readI64();
        else:
          iprot.skip(ftype)
      elif fid == 8:
        if ftype == TType.I64:
          self.all_record_nr = iprot.readI64();
        else:
          iprot.skip(ftype)
      elif fid == 9:
        if ftype == TType.LIST:
          self.locations = []
          (_etype270, _size267) = iprot.readListBegin()
          for _i271 in xrange(_size267):
            _elem272 = SFileLocation()
            _elem272.read(iprot)
            self.locations.append(_elem272)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 10:
        if ftype == TType.I64:
          self.length = iprot.readI64();
        else:
          iprot.skip(ftype)
      elif fid == 11:
        if ftype == TType.LIST:
          self.values = []
          (_etype276, _size273) = iprot.readListBegin()
          for _i277 in xrange(_size273):
            _elem278 = SplitValue()
            _elem278.read(iprot)
            self.values.append(_elem278)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('SFile')
    if self.fid is not None:
      oprot.writeFieldBegin('fid', TType.I64, 1)
      oprot.writeI64(self.fid)
      oprot.writeFieldEnd()
    if self.dbName is not None:
      oprot.writeFieldBegin('dbName', TType.STRING, 2)
      oprot.writeString(self.dbName)
      oprot.writeFieldEnd()
    if self.tableName is not None:
      oprot.writeFieldBegin('tableName', TType.STRING, 3)
      oprot.writeString(self.tableName)
      oprot.writeFieldEnd()
    if self.store_status is not None:
      oprot.writeFieldBegin('store_status', TType.I32, 4)
      oprot.writeI32(self.store_status)
      oprot.writeFieldEnd()
    if self.rep_nr is not None:
      oprot.writeFieldBegin('rep_nr', TType.I32, 5)
      oprot.writeI32(self.rep_nr)
      oprot.writeFieldEnd()
    if self.digest is not None:
      oprot.writeFieldBegin('digest', TType.STRING, 6)
      oprot.writeString(self.digest)
      oprot.writeFieldEnd()
    if self.record_nr is not None:
      oprot.writeFieldBegin('record_nr', TType.I64, 7)
      oprot.writeI64(self.record_nr)
      oprot.writeFieldEnd()
    if self.all_record_nr is not None:
      oprot.writeFieldBegin('all_record_nr', TType.I64, 8)
      oprot.writeI64(self.all_record_nr)
      oprot.writeFieldEnd()
    if self.locations is not None:
      oprot.writeFieldBegin('locations', TType.LIST, 9)
      oprot.writeListBegin(TType.STRUCT, len(self.locations))
      for iter279 in self.locations:
        iter279.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.length is not None:
      oprot.writeFieldBegin('length', TType.I64, 10)
      oprot.writeI64(self.length)
      oprot.writeFieldEnd()
    if self.values is not None:
      oprot.writeFieldBegin('values', TType.LIST, 11)
      oprot.writeListBegin(TType.STRUCT, len(self.values))
      for iter280 in self.values:
        iter280.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class SFileRef:
  """
  Attributes:
   - file
   - origin_fid
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'file', (SFile, SFile.thrift_spec), None, ), # 1
    (2, TType.I64, 'origin_fid', None, None, ), # 2
  )

  def __init__(self, file=None, origin_fid=None,):
    self.file = file
    self.origin_fid = origin_fid

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.file = SFile()
          self.file.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I64:
          self.origin_fid = iprot.readI64();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('SFileRef')
    if self.file is not None:
      oprot.writeFieldBegin('file', TType.STRUCT, 1)
      self.file.write(oprot)
      oprot.writeFieldEnd()
    if self.origin_fid is not None:
      oprot.writeFieldBegin('origin_fid', TType.I64, 2)
      oprot.writeI64(self.origin_fid)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class Busitype:
  """
  Attributes:
   - name
   - comment
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'name', None, None, ), # 1
    (2, TType.STRING, 'comment', None, None, ), # 2
  )

  def __init__(self, name=None, comment=None,):
    self.name = name
    self.comment = comment

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.name = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.comment = iprot.readString();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('Busitype')
    if self.name is not None:
      oprot.writeFieldBegin('name', TType.STRING, 1)
      oprot.writeString(self.name)
      oprot.writeFieldEnd()
    if self.comment is not None:
      oprot.writeFieldBegin('comment', TType.STRING, 2)
      oprot.writeString(self.comment)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class Index:
  """
  Attributes:
   - indexName
   - indexHandlerClass
   - dbName
   - origTableName
   - createTime
   - lastAccessTime
   - indexTableName
   - sd
   - parameters
   - deferredRebuild
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'indexName', None, None, ), # 1
    (2, TType.STRING, 'indexHandlerClass', None, None, ), # 2
    (3, TType.STRING, 'dbName', None, None, ), # 3
    (4, TType.STRING, 'origTableName', None, None, ), # 4
    (5, TType.I32, 'createTime', None, None, ), # 5
    (6, TType.I32, 'lastAccessTime', None, None, ), # 6
    (7, TType.STRING, 'indexTableName', None, None, ), # 7
    (8, TType.STRUCT, 'sd', (StorageDescriptor, StorageDescriptor.thrift_spec), None, ), # 8
    (9, TType.MAP, 'parameters', (TType.STRING,None,TType.STRING,None), None, ), # 9
    (10, TType.BOOL, 'deferredRebuild', None, None, ), # 10
  )

  def __init__(self, indexName=None, indexHandlerClass=None, dbName=None, origTableName=None, createTime=None, lastAccessTime=None, indexTableName=None, sd=None, parameters=None, deferredRebuild=None,):
    self.indexName = indexName
    self.indexHandlerClass = indexHandlerClass
    self.dbName = dbName
    self.origTableName = origTableName
    self.createTime = createTime
    self.lastAccessTime = lastAccessTime
    self.indexTableName = indexTableName
    self.sd = sd
    self.parameters = parameters
    self.deferredRebuild = deferredRebuild

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.indexName = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.indexHandlerClass = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRING:
          self.dbName = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRING:
          self.origTableName = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.I32:
          self.createTime = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.I32:
          self.lastAccessTime = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 7:
        if ftype == TType.STRING:
          self.indexTableName = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 8:
        if ftype == TType.STRUCT:
          self.sd = StorageDescriptor()
          self.sd.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 9:
        if ftype == TType.MAP:
          self.parameters = {}
          (_ktype282, _vtype283, _size281 ) = iprot.readMapBegin() 
          for _i285 in xrange(_size281):
            _key286 = iprot.readString();
            _val287 = iprot.readString();
            self.parameters[_key286] = _val287
          iprot.readMapEnd()
        else:
          iprot.skip(ftype)
      elif fid == 10:
        if ftype == TType.BOOL:
          self.deferredRebuild = iprot.readBool();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('Index')
    if self.indexName is not None:
      oprot.writeFieldBegin('indexName', TType.STRING, 1)
      oprot.writeString(self.indexName)
      oprot.writeFieldEnd()
    if self.indexHandlerClass is not None:
      oprot.writeFieldBegin('indexHandlerClass', TType.STRING, 2)
      oprot.writeString(self.indexHandlerClass)
      oprot.writeFieldEnd()
    if self.dbName is not None:
      oprot.writeFieldBegin('dbName', TType.STRING, 3)
      oprot.writeString(self.dbName)
      oprot.writeFieldEnd()
    if self.origTableName is not None:
      oprot.writeFieldBegin('origTableName', TType.STRING, 4)
      oprot.writeString(self.origTableName)
      oprot.writeFieldEnd()
    if self.createTime is not None:
      oprot.writeFieldBegin('createTime', TType.I32, 5)
      oprot.writeI32(self.createTime)
      oprot.writeFieldEnd()
    if self.lastAccessTime is not None:
      oprot.writeFieldBegin('lastAccessTime', TType.I32, 6)
      oprot.writeI32(self.lastAccessTime)
      oprot.writeFieldEnd()
    if self.indexTableName is not None:
      oprot.writeFieldBegin('indexTableName', TType.STRING, 7)
      oprot.writeString(self.indexTableName)
      oprot.writeFieldEnd()
    if self.sd is not None:
      oprot.writeFieldBegin('sd', TType.STRUCT, 8)
      self.sd.write(oprot)
      oprot.writeFieldEnd()
    if self.parameters is not None:
      oprot.writeFieldBegin('parameters', TType.MAP, 9)
      oprot.writeMapBegin(TType.STRING, TType.STRING, len(self.parameters))
      for kiter288,viter289 in self.parameters.items():
        oprot.writeString(kiter288)
        oprot.writeString(viter289)
      oprot.writeMapEnd()
      oprot.writeFieldEnd()
    if self.deferredRebuild is not None:
      oprot.writeFieldBegin('deferredRebuild', TType.BOOL, 10)
      oprot.writeBool(self.deferredRebuild)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class BooleanColumnStatsData:
  """
  Attributes:
   - numTrues
   - numFalses
   - numNulls
  """

  thrift_spec = (
    None, # 0
    (1, TType.I64, 'numTrues', None, None, ), # 1
    (2, TType.I64, 'numFalses', None, None, ), # 2
    (3, TType.I64, 'numNulls', None, None, ), # 3
  )

  def __init__(self, numTrues=None, numFalses=None, numNulls=None,):
    self.numTrues = numTrues
    self.numFalses = numFalses
    self.numNulls = numNulls

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I64:
          self.numTrues = iprot.readI64();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I64:
          self.numFalses = iprot.readI64();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.I64:
          self.numNulls = iprot.readI64();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('BooleanColumnStatsData')
    if self.numTrues is not None:
      oprot.writeFieldBegin('numTrues', TType.I64, 1)
      oprot.writeI64(self.numTrues)
      oprot.writeFieldEnd()
    if self.numFalses is not None:
      oprot.writeFieldBegin('numFalses', TType.I64, 2)
      oprot.writeI64(self.numFalses)
      oprot.writeFieldEnd()
    if self.numNulls is not None:
      oprot.writeFieldBegin('numNulls', TType.I64, 3)
      oprot.writeI64(self.numNulls)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.numTrues is None:
      raise TProtocol.TProtocolException(message='Required field numTrues is unset!')
    if self.numFalses is None:
      raise TProtocol.TProtocolException(message='Required field numFalses is unset!')
    if self.numNulls is None:
      raise TProtocol.TProtocolException(message='Required field numNulls is unset!')
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class DoubleColumnStatsData:
  """
  Attributes:
   - lowValue
   - highValue
   - numNulls
   - numDVs
  """

  thrift_spec = (
    None, # 0
    (1, TType.DOUBLE, 'lowValue', None, None, ), # 1
    (2, TType.DOUBLE, 'highValue', None, None, ), # 2
    (3, TType.I64, 'numNulls', None, None, ), # 3
    (4, TType.I64, 'numDVs', None, None, ), # 4
  )

  def __init__(self, lowValue=None, highValue=None, numNulls=None, numDVs=None,):
    self.lowValue = lowValue
    self.highValue = highValue
    self.numNulls = numNulls
    self.numDVs = numDVs

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.DOUBLE:
          self.lowValue = iprot.readDouble();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.DOUBLE:
          self.highValue = iprot.readDouble();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.I64:
          self.numNulls = iprot.readI64();
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.I64:
          self.numDVs = iprot.readI64();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('DoubleColumnStatsData')
    if self.lowValue is not None:
      oprot.writeFieldBegin('lowValue', TType.DOUBLE, 1)
      oprot.writeDouble(self.lowValue)
      oprot.writeFieldEnd()
    if self.highValue is not None:
      oprot.writeFieldBegin('highValue', TType.DOUBLE, 2)
      oprot.writeDouble(self.highValue)
      oprot.writeFieldEnd()
    if self.numNulls is not None:
      oprot.writeFieldBegin('numNulls', TType.I64, 3)
      oprot.writeI64(self.numNulls)
      oprot.writeFieldEnd()
    if self.numDVs is not None:
      oprot.writeFieldBegin('numDVs', TType.I64, 4)
      oprot.writeI64(self.numDVs)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.lowValue is None:
      raise TProtocol.TProtocolException(message='Required field lowValue is unset!')
    if self.highValue is None:
      raise TProtocol.TProtocolException(message='Required field highValue is unset!')
    if self.numNulls is None:
      raise TProtocol.TProtocolException(message='Required field numNulls is unset!')
    if self.numDVs is None:
      raise TProtocol.TProtocolException(message='Required field numDVs is unset!')
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class LongColumnStatsData:
  """
  Attributes:
   - lowValue
   - highValue
   - numNulls
   - numDVs
  """

  thrift_spec = (
    None, # 0
    (1, TType.I64, 'lowValue', None, None, ), # 1
    (2, TType.I64, 'highValue', None, None, ), # 2
    (3, TType.I64, 'numNulls', None, None, ), # 3
    (4, TType.I64, 'numDVs', None, None, ), # 4
  )

  def __init__(self, lowValue=None, highValue=None, numNulls=None, numDVs=None,):
    self.lowValue = lowValue
    self.highValue = highValue
    self.numNulls = numNulls
    self.numDVs = numDVs

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I64:
          self.lowValue = iprot.readI64();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I64:
          self.highValue = iprot.readI64();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.I64:
          self.numNulls = iprot.readI64();
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.I64:
          self.numDVs = iprot.readI64();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('LongColumnStatsData')
    if self.lowValue is not None:
      oprot.writeFieldBegin('lowValue', TType.I64, 1)
      oprot.writeI64(self.lowValue)
      oprot.writeFieldEnd()
    if self.highValue is not None:
      oprot.writeFieldBegin('highValue', TType.I64, 2)
      oprot.writeI64(self.highValue)
      oprot.writeFieldEnd()
    if self.numNulls is not None:
      oprot.writeFieldBegin('numNulls', TType.I64, 3)
      oprot.writeI64(self.numNulls)
      oprot.writeFieldEnd()
    if self.numDVs is not None:
      oprot.writeFieldBegin('numDVs', TType.I64, 4)
      oprot.writeI64(self.numDVs)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.lowValue is None:
      raise TProtocol.TProtocolException(message='Required field lowValue is unset!')
    if self.highValue is None:
      raise TProtocol.TProtocolException(message='Required field highValue is unset!')
    if self.numNulls is None:
      raise TProtocol.TProtocolException(message='Required field numNulls is unset!')
    if self.numDVs is None:
      raise TProtocol.TProtocolException(message='Required field numDVs is unset!')
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class StringColumnStatsData:
  """
  Attributes:
   - maxColLen
   - avgColLen
   - numNulls
   - numDVs
  """

  thrift_spec = (
    None, # 0
    (1, TType.I64, 'maxColLen', None, None, ), # 1
    (2, TType.DOUBLE, 'avgColLen', None, None, ), # 2
    (3, TType.I64, 'numNulls', None, None, ), # 3
    (4, TType.I64, 'numDVs', None, None, ), # 4
  )

  def __init__(self, maxColLen=None, avgColLen=None, numNulls=None, numDVs=None,):
    self.maxColLen = maxColLen
    self.avgColLen = avgColLen
    self.numNulls = numNulls
    self.numDVs = numDVs

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I64:
          self.maxColLen = iprot.readI64();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.DOUBLE:
          self.avgColLen = iprot.readDouble();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.I64:
          self.numNulls = iprot.readI64();
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.I64:
          self.numDVs = iprot.readI64();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('StringColumnStatsData')
    if self.maxColLen is not None:
      oprot.writeFieldBegin('maxColLen', TType.I64, 1)
      oprot.writeI64(self.maxColLen)
      oprot.writeFieldEnd()
    if self.avgColLen is not None:
      oprot.writeFieldBegin('avgColLen', TType.DOUBLE, 2)
      oprot.writeDouble(self.avgColLen)
      oprot.writeFieldEnd()
    if self.numNulls is not None:
      oprot.writeFieldBegin('numNulls', TType.I64, 3)
      oprot.writeI64(self.numNulls)
      oprot.writeFieldEnd()
    if self.numDVs is not None:
      oprot.writeFieldBegin('numDVs', TType.I64, 4)
      oprot.writeI64(self.numDVs)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.maxColLen is None:
      raise TProtocol.TProtocolException(message='Required field maxColLen is unset!')
    if self.avgColLen is None:
      raise TProtocol.TProtocolException(message='Required field avgColLen is unset!')
    if self.numNulls is None:
      raise TProtocol.TProtocolException(message='Required field numNulls is unset!')
    if self.numDVs is None:
      raise TProtocol.TProtocolException(message='Required field numDVs is unset!')
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class BinaryColumnStatsData:
  """
  Attributes:
   - maxColLen
   - avgColLen
   - numNulls
  """

  thrift_spec = (
    None, # 0
    (1, TType.I64, 'maxColLen', None, None, ), # 1
    (2, TType.DOUBLE, 'avgColLen', None, None, ), # 2
    (3, TType.I64, 'numNulls', None, None, ), # 3
  )

  def __init__(self, maxColLen=None, avgColLen=None, numNulls=None,):
    self.maxColLen = maxColLen
    self.avgColLen = avgColLen
    self.numNulls = numNulls

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I64:
          self.maxColLen = iprot.readI64();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.DOUBLE:
          self.avgColLen = iprot.readDouble();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.I64:
          self.numNulls = iprot.readI64();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('BinaryColumnStatsData')
    if self.maxColLen is not None:
      oprot.writeFieldBegin('maxColLen', TType.I64, 1)
      oprot.writeI64(self.maxColLen)
      oprot.writeFieldEnd()
    if self.avgColLen is not None:
      oprot.writeFieldBegin('avgColLen', TType.DOUBLE, 2)
      oprot.writeDouble(self.avgColLen)
      oprot.writeFieldEnd()
    if self.numNulls is not None:
      oprot.writeFieldBegin('numNulls', TType.I64, 3)
      oprot.writeI64(self.numNulls)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.maxColLen is None:
      raise TProtocol.TProtocolException(message='Required field maxColLen is unset!')
    if self.avgColLen is None:
      raise TProtocol.TProtocolException(message='Required field avgColLen is unset!')
    if self.numNulls is None:
      raise TProtocol.TProtocolException(message='Required field numNulls is unset!')
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class ColumnStatisticsData:
  """
  Attributes:
   - booleanStats
   - longStats
   - doubleStats
   - stringStats
   - binaryStats
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'booleanStats', (BooleanColumnStatsData, BooleanColumnStatsData.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'longStats', (LongColumnStatsData, LongColumnStatsData.thrift_spec), None, ), # 2
    (3, TType.STRUCT, 'doubleStats', (DoubleColumnStatsData, DoubleColumnStatsData.thrift_spec), None, ), # 3
    (4, TType.STRUCT, 'stringStats', (StringColumnStatsData, StringColumnStatsData.thrift_spec), None, ), # 4
    (5, TType.STRUCT, 'binaryStats', (BinaryColumnStatsData, BinaryColumnStatsData.thrift_spec), None, ), # 5
  )

  def __init__(self, booleanStats=None, longStats=None, doubleStats=None, stringStats=None, binaryStats=None,):
    self.booleanStats = booleanStats
    self.longStats = longStats
    self.doubleStats = doubleStats
    self.stringStats = stringStats
    self.binaryStats = binaryStats

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.booleanStats = BooleanColumnStatsData()
          self.booleanStats.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.longStats = LongColumnStatsData()
          self.longStats.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.doubleStats = DoubleColumnStatsData()
          self.doubleStats.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRUCT:
          self.stringStats = StringColumnStatsData()
          self.stringStats.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.STRUCT:
          self.binaryStats = BinaryColumnStatsData()
          self.binaryStats.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('ColumnStatisticsData')
    if self.booleanStats is not None:
      oprot.writeFieldBegin('booleanStats', TType.STRUCT, 1)
      self.booleanStats.write(oprot)
      oprot.writeFieldEnd()
    if self.longStats is not None:
      oprot.writeFieldBegin('longStats', TType.STRUCT, 2)
      self.longStats.write(oprot)
      oprot.writeFieldEnd()
    if self.doubleStats is not None:
      oprot.writeFieldBegin('doubleStats', TType.STRUCT, 3)
      self.doubleStats.write(oprot)
      oprot.writeFieldEnd()
    if self.stringStats is not None:
      oprot.writeFieldBegin('stringStats', TType.STRUCT, 4)
      self.stringStats.write(oprot)
      oprot.writeFieldEnd()
    if self.binaryStats is not None:
      oprot.writeFieldBegin('binaryStats', TType.STRUCT, 5)
      self.binaryStats.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class ColumnStatisticsObj:
  """
  Attributes:
   - colName
   - colType
   - statsData
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'colName', None, None, ), # 1
    (2, TType.STRING, 'colType', None, None, ), # 2
    (3, TType.STRUCT, 'statsData', (ColumnStatisticsData, ColumnStatisticsData.thrift_spec), None, ), # 3
  )

  def __init__(self, colName=None, colType=None, statsData=None,):
    self.colName = colName
    self.colType = colType
    self.statsData = statsData

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.colName = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.colType = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.statsData = ColumnStatisticsData()
          self.statsData.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('ColumnStatisticsObj')
    if self.colName is not None:
      oprot.writeFieldBegin('colName', TType.STRING, 1)
      oprot.writeString(self.colName)
      oprot.writeFieldEnd()
    if self.colType is not None:
      oprot.writeFieldBegin('colType', TType.STRING, 2)
      oprot.writeString(self.colType)
      oprot.writeFieldEnd()
    if self.statsData is not None:
      oprot.writeFieldBegin('statsData', TType.STRUCT, 3)
      self.statsData.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.colName is None:
      raise TProtocol.TProtocolException(message='Required field colName is unset!')
    if self.colType is None:
      raise TProtocol.TProtocolException(message='Required field colType is unset!')
    if self.statsData is None:
      raise TProtocol.TProtocolException(message='Required field statsData is unset!')
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class ColumnStatisticsDesc:
  """
  Attributes:
   - isTblLevel
   - dbName
   - tableName
   - partName
   - lastAnalyzed
  """

  thrift_spec = (
    None, # 0
    (1, TType.BOOL, 'isTblLevel', None, None, ), # 1
    (2, TType.STRING, 'dbName', None, None, ), # 2
    (3, TType.STRING, 'tableName', None, None, ), # 3
    (4, TType.STRING, 'partName', None, None, ), # 4
    (5, TType.I64, 'lastAnalyzed', None, None, ), # 5
  )

  def __init__(self, isTblLevel=None, dbName=None, tableName=None, partName=None, lastAnalyzed=None,):
    self.isTblLevel = isTblLevel
    self.dbName = dbName
    self.tableName = tableName
    self.partName = partName
    self.lastAnalyzed = lastAnalyzed

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.BOOL:
          self.isTblLevel = iprot.readBool();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.dbName = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRING:
          self.tableName = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRING:
          self.partName = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.I64:
          self.lastAnalyzed = iprot.readI64();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('ColumnStatisticsDesc')
    if self.isTblLevel is not None:
      oprot.writeFieldBegin('isTblLevel', TType.BOOL, 1)
      oprot.writeBool(self.isTblLevel)
      oprot.writeFieldEnd()
    if self.dbName is not None:
      oprot.writeFieldBegin('dbName', TType.STRING, 2)
      oprot.writeString(self.dbName)
      oprot.writeFieldEnd()
    if self.tableName is not None:
      oprot.writeFieldBegin('tableName', TType.STRING, 3)
      oprot.writeString(self.tableName)
      oprot.writeFieldEnd()
    if self.partName is not None:
      oprot.writeFieldBegin('partName', TType.STRING, 4)
      oprot.writeString(self.partName)
      oprot.writeFieldEnd()
    if self.lastAnalyzed is not None:
      oprot.writeFieldBegin('lastAnalyzed', TType.I64, 5)
      oprot.writeI64(self.lastAnalyzed)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.isTblLevel is None:
      raise TProtocol.TProtocolException(message='Required field isTblLevel is unset!')
    if self.dbName is None:
      raise TProtocol.TProtocolException(message='Required field dbName is unset!')
    if self.tableName is None:
      raise TProtocol.TProtocolException(message='Required field tableName is unset!')
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class ColumnStatistics:
  """
  Attributes:
   - statsDesc
   - statsObj
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'statsDesc', (ColumnStatisticsDesc, ColumnStatisticsDesc.thrift_spec), None, ), # 1
    (2, TType.LIST, 'statsObj', (TType.STRUCT,(ColumnStatisticsObj, ColumnStatisticsObj.thrift_spec)), None, ), # 2
  )

  def __init__(self, statsDesc=None, statsObj=None,):
    self.statsDesc = statsDesc
    self.statsObj = statsObj

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.statsDesc = ColumnStatisticsDesc()
          self.statsDesc.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.LIST:
          self.statsObj = []
          (_etype293, _size290) = iprot.readListBegin()
          for _i294 in xrange(_size290):
            _elem295 = ColumnStatisticsObj()
            _elem295.read(iprot)
            self.statsObj.append(_elem295)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('ColumnStatistics')
    if self.statsDesc is not None:
      oprot.writeFieldBegin('statsDesc', TType.STRUCT, 1)
      self.statsDesc.write(oprot)
      oprot.writeFieldEnd()
    if self.statsObj is not None:
      oprot.writeFieldBegin('statsObj', TType.LIST, 2)
      oprot.writeListBegin(TType.STRUCT, len(self.statsObj))
      for iter296 in self.statsObj:
        iter296.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.statsDesc is None:
      raise TProtocol.TProtocolException(message='Required field statsDesc is unset!')
    if self.statsObj is None:
      raise TProtocol.TProtocolException(message='Required field statsObj is unset!')
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class Schema:
  """
  Attributes:
   - fieldSchemas
   - properties
  """

  thrift_spec = (
    None, # 0
    (1, TType.LIST, 'fieldSchemas', (TType.STRUCT,(FieldSchema, FieldSchema.thrift_spec)), None, ), # 1
    (2, TType.MAP, 'properties', (TType.STRING,None,TType.STRING,None), None, ), # 2
  )

  def __init__(self, fieldSchemas=None, properties=None,):
    self.fieldSchemas = fieldSchemas
    self.properties = properties

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.LIST:
          self.fieldSchemas = []
          (_etype300, _size297) = iprot.readListBegin()
          for _i301 in xrange(_size297):
            _elem302 = FieldSchema()
            _elem302.read(iprot)
            self.fieldSchemas.append(_elem302)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.MAP:
          self.properties = {}
          (_ktype304, _vtype305, _size303 ) = iprot.readMapBegin() 
          for _i307 in xrange(_size303):
            _key308 = iprot.readString();
            _val309 = iprot.readString();
            self.properties[_key308] = _val309
          iprot.readMapEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('Schema')
    if self.fieldSchemas is not None:
      oprot.writeFieldBegin('fieldSchemas', TType.LIST, 1)
      oprot.writeListBegin(TType.STRUCT, len(self.fieldSchemas))
      for iter310 in self.fieldSchemas:
        iter310.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.properties is not None:
      oprot.writeFieldBegin('properties', TType.MAP, 2)
      oprot.writeMapBegin(TType.STRING, TType.STRING, len(self.properties))
      for kiter311,viter312 in self.properties.items():
        oprot.writeString(kiter311)
        oprot.writeString(viter312)
      oprot.writeMapEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class EnvironmentContext:
  """
  Attributes:
   - properties
  """

  thrift_spec = (
    None, # 0
    (1, TType.MAP, 'properties', (TType.STRING,None,TType.STRING,None), None, ), # 1
  )

  def __init__(self, properties=None,):
    self.properties = properties

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.MAP:
          self.properties = {}
          (_ktype314, _vtype315, _size313 ) = iprot.readMapBegin() 
          for _i317 in xrange(_size313):
            _key318 = iprot.readString();
            _val319 = iprot.readString();
            self.properties[_key318] = _val319
          iprot.readMapEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('EnvironmentContext')
    if self.properties is not None:
      oprot.writeFieldBegin('properties', TType.MAP, 1)
      oprot.writeMapBegin(TType.STRING, TType.STRING, len(self.properties))
      for kiter320,viter321 in self.properties.items():
        oprot.writeString(kiter320)
        oprot.writeString(viter321)
      oprot.writeMapEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class GeoLocation:
  """
  Attributes:
   - geoLocName
   - nation
   - province
   - city
   - dist
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'geoLocName', None, None, ), # 1
    (2, TType.STRING, 'nation', None, None, ), # 2
    (3, TType.STRING, 'province', None, None, ), # 3
    (4, TType.STRING, 'city', None, None, ), # 4
    (5, TType.STRING, 'dist', None, None, ), # 5
  )

  def __init__(self, geoLocName=None, nation=None, province=None, city=None, dist=None,):
    self.geoLocName = geoLocName
    self.nation = nation
    self.province = province
    self.city = city
    self.dist = dist

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.geoLocName = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.nation = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRING:
          self.province = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRING:
          self.city = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.STRING:
          self.dist = iprot.readString();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('GeoLocation')
    if self.geoLocName is not None:
      oprot.writeFieldBegin('geoLocName', TType.STRING, 1)
      oprot.writeString(self.geoLocName)
      oprot.writeFieldEnd()
    if self.nation is not None:
      oprot.writeFieldBegin('nation', TType.STRING, 2)
      oprot.writeString(self.nation)
      oprot.writeFieldEnd()
    if self.province is not None:
      oprot.writeFieldBegin('province', TType.STRING, 3)
      oprot.writeString(self.province)
      oprot.writeFieldEnd()
    if self.city is not None:
      oprot.writeFieldBegin('city', TType.STRING, 4)
      oprot.writeString(self.city)
      oprot.writeFieldEnd()
    if self.dist is not None:
      oprot.writeFieldBegin('dist', TType.STRING, 5)
      oprot.writeString(self.dist)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.geoLocName is None:
      raise TProtocol.TProtocolException(message='Required field geoLocName is unset!')
    if self.nation is None:
      raise TProtocol.TProtocolException(message='Required field nation is unset!')
    if self.province is None:
      raise TProtocol.TProtocolException(message='Required field province is unset!')
    if self.city is None:
      raise TProtocol.TProtocolException(message='Required field city is unset!')
    if self.dist is None:
      raise TProtocol.TProtocolException(message='Required field dist is unset!')
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class EquipRoom:
  """
  Attributes:
   - eqRoomName
   - status
   - comment
   - geolocation
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'eqRoomName', None, None, ), # 1
    (2, TType.I32, 'status', None, None, ), # 2
    (3, TType.STRING, 'comment', None, None, ), # 3
    (4, TType.STRUCT, 'geolocation', (GeoLocation, GeoLocation.thrift_spec), None, ), # 4
  )

  def __init__(self, eqRoomName=None, status=None, comment=None, geolocation=None,):
    self.eqRoomName = eqRoomName
    self.status = status
    self.comment = comment
    self.geolocation = geolocation

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.eqRoomName = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I32:
          self.status = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRING:
          self.comment = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRUCT:
          self.geolocation = GeoLocation()
          self.geolocation.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('EquipRoom')
    if self.eqRoomName is not None:
      oprot.writeFieldBegin('eqRoomName', TType.STRING, 1)
      oprot.writeString(self.eqRoomName)
      oprot.writeFieldEnd()
    if self.status is not None:
      oprot.writeFieldBegin('status', TType.I32, 2)
      oprot.writeI32(self.status)
      oprot.writeFieldEnd()
    if self.comment is not None:
      oprot.writeFieldBegin('comment', TType.STRING, 3)
      oprot.writeString(self.comment)
      oprot.writeFieldEnd()
    if self.geolocation is not None:
      oprot.writeFieldBegin('geolocation', TType.STRUCT, 4)
      self.geolocation.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.eqRoomName is None:
      raise TProtocol.TProtocolException(message='Required field eqRoomName is unset!')
    if self.status is None:
      raise TProtocol.TProtocolException(message='Required field status is unset!')
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class PingPong:
  """
  Attributes:
   - len
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, 'len', None, None, ), # 1
  )

  def __init__(self, len=None,):
    self.len = len

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.len = iprot.readI32();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('PingPong')
    if self.len is not None:
      oprot.writeFieldBegin('len', TType.I32, 1)
      oprot.writeI32(self.len)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.len is None:
      raise TProtocol.TProtocolException(message='Required field len is unset!')
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class MetaException(TException):
  """
  Attributes:
   - message
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'message', None, None, ), # 1
  )

  def __init__(self, message=None,):
    self.message = message

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.message = iprot.readString();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('MetaException')
    if self.message is not None:
      oprot.writeFieldBegin('message', TType.STRING, 1)
      oprot.writeString(self.message)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __str__(self):
    return repr(self)

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class UnknownTableException(TException):
  """
  Attributes:
   - message
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'message', None, None, ), # 1
  )

  def __init__(self, message=None,):
    self.message = message

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.message = iprot.readString();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('UnknownTableException')
    if self.message is not None:
      oprot.writeFieldBegin('message', TType.STRING, 1)
      oprot.writeString(self.message)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __str__(self):
    return repr(self)

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class UnknownDBException(TException):
  """
  Attributes:
   - message
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'message', None, None, ), # 1
  )

  def __init__(self, message=None,):
    self.message = message

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.message = iprot.readString();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('UnknownDBException')
    if self.message is not None:
      oprot.writeFieldBegin('message', TType.STRING, 1)
      oprot.writeString(self.message)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __str__(self):
    return repr(self)

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class AlreadyExistsException(TException):
  """
  Attributes:
   - message
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'message', None, None, ), # 1
  )

  def __init__(self, message=None,):
    self.message = message

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.message = iprot.readString();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('AlreadyExistsException')
    if self.message is not None:
      oprot.writeFieldBegin('message', TType.STRING, 1)
      oprot.writeString(self.message)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __str__(self):
    return repr(self)

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class InvalidPartitionException(TException):
  """
  Attributes:
   - message
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'message', None, None, ), # 1
  )

  def __init__(self, message=None,):
    self.message = message

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.message = iprot.readString();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('InvalidPartitionException')
    if self.message is not None:
      oprot.writeFieldBegin('message', TType.STRING, 1)
      oprot.writeString(self.message)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __str__(self):
    return repr(self)

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class UnknownPartitionException(TException):
  """
  Attributes:
   - message
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'message', None, None, ), # 1
  )

  def __init__(self, message=None,):
    self.message = message

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.message = iprot.readString();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('UnknownPartitionException')
    if self.message is not None:
      oprot.writeFieldBegin('message', TType.STRING, 1)
      oprot.writeString(self.message)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __str__(self):
    return repr(self)

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class InvalidObjectException(TException):
  """
  Attributes:
   - message
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'message', None, None, ), # 1
  )

  def __init__(self, message=None,):
    self.message = message

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.message = iprot.readString();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('InvalidObjectException')
    if self.message is not None:
      oprot.writeFieldBegin('message', TType.STRING, 1)
      oprot.writeString(self.message)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __str__(self):
    return repr(self)

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class NoSuchObjectException(TException):
  """
  Attributes:
   - message
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'message', None, None, ), # 1
  )

  def __init__(self, message=None,):
    self.message = message

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.message = iprot.readString();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('NoSuchObjectException')
    if self.message is not None:
      oprot.writeFieldBegin('message', TType.STRING, 1)
      oprot.writeString(self.message)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __str__(self):
    return repr(self)

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class IndexAlreadyExistsException(TException):
  """
  Attributes:
   - message
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'message', None, None, ), # 1
  )

  def __init__(self, message=None,):
    self.message = message

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.message = iprot.readString();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('IndexAlreadyExistsException')
    if self.message is not None:
      oprot.writeFieldBegin('message', TType.STRING, 1)
      oprot.writeString(self.message)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __str__(self):
    return repr(self)

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class InvalidOperationException(TException):
  """
  Attributes:
   - message
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'message', None, None, ), # 1
  )

  def __init__(self, message=None,):
    self.message = message

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.message = iprot.readString();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('InvalidOperationException')
    if self.message is not None:
      oprot.writeFieldBegin('message', TType.STRING, 1)
      oprot.writeString(self.message)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __str__(self):
    return repr(self)

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class ConfigValSecurityException(TException):
  """
  Attributes:
   - message
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'message', None, None, ), # 1
  )

  def __init__(self, message=None,):
    self.message = message

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.message = iprot.readString();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('ConfigValSecurityException')
    if self.message is not None:
      oprot.writeFieldBegin('message', TType.STRING, 1)
      oprot.writeString(self.message)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __str__(self):
    return repr(self)

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class InvalidInputException(TException):
  """
  Attributes:
   - message
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'message', None, None, ), # 1
  )

  def __init__(self, message=None,):
    self.message = message

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.message = iprot.readString();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('InvalidInputException')
    if self.message is not None:
      oprot.writeFieldBegin('message', TType.STRING, 1)
      oprot.writeString(self.message)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __str__(self):
    return repr(self)

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class FileOperationException(TException):
  """
  Attributes:
   - message
   - reason
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'message', None, None, ), # 1
    (2, TType.I32, 'reason', None, None, ), # 2
  )

  def __init__(self, message=None, reason=None,):
    self.message = message
    self.reason = reason

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.message = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I32:
          self.reason = iprot.readI32();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('FileOperationException')
    if self.message is not None:
      oprot.writeFieldBegin('message', TType.STRING, 1)
      oprot.writeString(self.message)
      oprot.writeFieldEnd()
    if self.reason is not None:
      oprot.writeFieldBegin('reason', TType.I32, 2)
      oprot.writeI32(self.reason)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __str__(self):
    return repr(self)

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)
